[TOC]



# 图论

## 最短路

### Dijkstra

``` cpp
#include <bits/stdc++.h>
using namespace std;
#define reset(x) memset(x,0,sizeof x)
#define reset3f(x) memset(x,0x3f,sizeof x)
namespace sp {
const int N=1e+6+5;
vector<pair<int,int> > g[N];
int n,v0=1,d[N],v[N];
void make(int t1,int t2,int t3) {
    g[t1].push_back(make_pair(t2,t3));
}
void reset_graph() {
    for(int i=0;i<=n;i++) g[i].clear();
}
void solve() {
    priority_queue<pair<int,int> > qu;
    reset3f(d);reset(v);
    d[v0]=0;
    qu.push(make_pair(0,v0));
    while(qu.size()) {
        int p=qu.top().second,r=qu.top().first;
        qu.pop();
        if(r+d[p]) continue;
        for(int i=0;i<g[p].size();i++) {
            int q=g[p][i].first,w=g[p][i].second;
            if(d[q]>d[p]+w) {
                d[q]=d[p]+w;
                qu.push(make_pair(-d[q],q));
            }
        }
    }
}
}
int n,m,s,t1,t2,t3;
int main() {
    scanf("%d%d%d",&n,&m,&s);
    sp::n=n; sp::v0=s;
    for(int i=1;i<=m;i++) {
        scanf("%d%d%d",&t1,&t2,&t3);
        sp::make(t1,t2,t3);
    }
    sp::solve();
    for(int i=1;i<=n;i++) {
        printf("%d ",sp::d[i]>=0x3f3f3f3f?2147483647:sp::d[i]);
    }
}

```

### SPFA

``` cpp
// 参数：点数n  源点v0
// 方法：make建边  reset_graph清图  solve计算
// 输出：d最短路数组
namespace sp {
const int N=1e+6+5;
vector<pair<int,int> > g[N];
int n,v0=1,d[N],v[N];
void make(int t1,int t2,int t3) {
    g[t1].push_back(make_pair(t2,t3));
}
void reset_graph() {
    for(int i=0;i<=n;i++) g[i].clear();
}
void solve() {
    queue <int> qu;
    reset(v); reset3f(d);
    d[v0]=0; v[v0]=1; qu.push(v0);
    while(qu.size()) {
        int p=qu.front();
        qu.pop();
        v[p]=0;
        for(int i=0;i<g[p].size();i++) {
            int q=g[p][i].first,w=g[p][i].second;
            if(d[q]>d[p]+w) {
                d[q]=d[p]+w;
                if(!v[q]) qu.push(q), v[q]=1;
            }
        }
    }
}
}

```

### Johnson

``` cpp
// 参数： n,m
// 方法： 加边make 计算solve
// 结果： 有负环fg 距离数组ans
namespace sp {
const int N=4e3+10;
struct node {
    int to,dis,nxt;
} e[N<<3];
int head[N],n,m,cnt,app[N],res[N],ans[N][N],tmp[N],fg;
bool vis[N];
inline void make(int u,int v,int w) {
    e[++cnt].dis=w;
    e[cnt].nxt=head[u];
    e[cnt].to=v;
    head[u]=cnt;
}
inline bool spfa(int s) {
    queue<int> q;
    reset3f(res);
    q.push(s);
    vis[s]=1;
    res[s]=0;
    while(!q.empty()) {
        int fr=q.front();
        q.pop();
        vis[fr]=0;
        for(int i=head[fr]; i; i=e[i].nxt) {
            int t=e[i].to,dist=e[i].dis+res[fr];
            if(res[t]>dist) {
                res[t]=dist;
                if(!vis[t]) {
                    if(++app[t]>=n) return 0;
                    vis[t]=1;
                    q.push(t);
                }
            }
        }
    }
    return 1;
}
#define mp make_pair
inline void dij(int s) {
    priority_queue<pair<int,int> > q;
    q.push(mp(0,s));
    reset(vis);
    for(int i=1; i<=n; ++i) tmp[i]=1e9;
    tmp[s]=0;
    while(!q.empty()) {
        int fr=q.top().second;
        q.pop();
        if(vis[fr]) continue;
        vis[fr]=1;
        for(int i=head[fr]; i; i=e[i].nxt) {
            int t=e[i].to,dist=e[i].dis+tmp[fr];
            if(tmp[t]>dist) {
                tmp[t]=dist;
                if(!vis[t]) q.push(mp(-dist,t));
            }
        }
    }
    for(int i=1; i<=n; ++i) {
        if(tmp[i]==1e9) ans[s][i]=tmp[i];
        else ans[s][i]=tmp[i]+res[i]-res[s];
    }
}
void solve() {
    reset(ans);
    for(int i=1; i<=n; ++i) make(n+1,i,0);
    if(!spfa(n+1)) {
        fg=1;
        return;
    }
    for(int i=1; i<=n; ++i)
        for(int j=head[i]; j; j=e[j].nxt)
            e[j].dis+=res[i]-res[e[j].to];
    for(int i=1; i<=n; ++i) dij(i);
}
}

```

## 负环

### DFS

``` cpp
#include <bits/stdc++.h>
using namespace std;

int n,m,ins[1000005],vis[1000005],dis[1000005],fg=0,t1,t2,t3,T;

vector <pair<int,int> > g[1000005];

void dfs(int p){
	ins[p]=1; vis[p]=1;
	for(int i=0;i<g[p].size()&&!fg;i++)
		if(dis[g[p][i].first]>dis[p]+g[p][i].second){
			dis[g[p][i].first]=dis[p]+g[p][i].second;
			if(ins[g[p][i].first]==0)
				dfs(g[p][i].first);
			else {fg=1; return;}}
	ins[p]=0;
}

int main(){
	scanf("%d",&T);
	while(T--){
		n=m=fg=0; memset(ins,0,sizeof ins); memset(vis,0,sizeof vis); memset(dis,0,sizeof dis);
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;i++) g[i].clear();
		for(int i=1;i<=m;i++){
			scanf("%d%d%d",&t1,&t2,&t3),
			g[t1].push_back(make_pair(t2,t3));
			if(t3>=0) g[t2].push_back(make_pair(t1,t3));
		}
		for(int i=1;i<=n;i++)
			if(vis[i]==0) dis[i]=0, dfs(i);
		if(fg==1) printf("YE5\n");
		else printf("N0\n");
	}
}

```

### SPFA

``` cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
#include<vector>
using namespace std;
const int maxn=200001;
struct edge{int from,to,dist;};
int ____________a,b,c,d,n,m,u,v,val,dis[maxn];
vector<edge>edges;
vector<int>g[maxn];
bool vis[maxn],flag;
void spfa(int u){
    vis[u]=1;
    for(int i=0;i<g[u].size();i++){
        edge &e=edges[g[u][i]];
        int v=e.to;
        if(dis[v]>dis[u]+e.dist){
            dis[v]=dis[u]+e.dist;
            if(vis[v]){
                flag=1;
                return ;}
            spfa(v);}}
    vis[u]=0; }
inline void init()
{
    for(int i=1;i<=n;i++) g[i].clear();
    edges.clear();
    memset(dis,0,sizeof(dis));
    memset(vis,0,sizeof(vis));
}
inline void addedge()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&u,&v,&val);
        edges.push_back((edge){u,v,val});
        g[u].push_back(edges.size()-1);
        if(val>0)
        {
        edges.push_back((edge){v,u,val});
        g[v].push_back(edges.size()-1);
        }
    }
}
inline bool judge()
{
    flag=0;
    for(int i=1;i<=n;i++)
    {
        spfa(i);
        if(flag) return 1;
    }
    return 0;
}
inline void solve()
{
    int t;
    cin>>t;
    while(t--)
    {
        init();
        addedge();
        if(judge()) cout<<"YE5"<<endl;
        else cout<<"N0"<<endl;
    }
}
int main(){
    solve();
    return 0;
}

```





## 最小生成树

### Kruskal

``` cpp
template <class T> class Graph_MST_Kruskal { // 使用Kruskal算法计算最小生成树
public:
	struct ufs {
		int fa[MAX_NODE];
		void reset(int maxnode) {
			for (int i = 0; i <= maxnode; i++) fa[i] = i;
		}
		ufs(int maxnode) {
			reset(maxnode);
		}
		ufs() {
			reset(MAX_NODE);
		}
		int find(int p) {
			int t = p, tt = p, tmp;
			while (t && fa[t] - t) t = fa[t];
			while (tt && fa[tt] - tt) tmp = fa[tt], fa[tt] = t, tt = tmp;
			return t;
		}
		void merge(int p, int q) {
			p = find(p);
			q = find(q);
			if (p - q) fa[p] = q;
		}
	} s;
	struct edge {
		int u, v;
		T w;
		bool operator < (const edge& x) const {
			return (this->w < x.w);
		}
	} e[MAX_EDGE];
	int n, m;
	T ans;
	void reset_graph() {
		memset(e, 0, sizeof e);
		n = m = 0;
	}
	void reset_solver(int numNodes) {
		n = numNodes;
		ans = 0; // 类型依赖
		s.reset(numNodes);
	}
	void make_edge(int u, int v, T w) {
		edge tmp;
		tmp.u = u;
		tmp.v = v;
		tmp.w = w;
		e[++m] = tmp;
	}
	T solve(int numNodes) { // 执行主计算任务
		reset_solver(numNodes);
		sort(e + 1, e + m + 1);
		for (int i = 1; i <= m; i++) {
			if (s.find(e[i].u) - s.find(e[i].v))
				s.merge(e[i].u, e[i].v),
				ans += e[i].w;
		}
		return ans;
	}
};

```

### Prim

``` cpp
template <class T> class Graph_MST_Prim_Adjlist { // 使用邻接表上的Prim算法解决最小生成树问题
public:
	vector<pair<int, T> >G[MAX_NODE];
	int d[MAX_NODE], v[MAX_NODE]; // 距离表与访问标识表
	int ans = 0;
	int v0 = 0; // 扫描的起始点
	void make_edge(int t1, int t2, T t3) { // 造边（无向）
		G[t1].push_back(make_pair(t2, t3));
		G[t2].push_back(make_pair(t1, t3));
	}
	void reset_graph(int n) { // 用于清除图邻接表
		for (int i = 0; i <= n; i++)
			G[i].clear();
	}
	void reset_solver(int n) { // 对距离表与访问标识表的清除 如果改变了类型，该函数可能需要重写！
		memset(d, 0x3f, sizeof d);
		memset(v, 0x00, sizeof v);
		ans = 0;
	}
	int solve(int n) { // 执行主计算任务
		v0 = 1; // 扫描的起始点，可修改
		priority_queue<pair<T, int>, vector<pair<T, int> >, greater<pair<T, int> > >q;
		reset_solver(n); // 自动调用对距离表与访问标识表的清除
		d[v0] = 0;
		q.push(make_pair(0, v0));
		while (q.size()) {
			pair<T, int> p = q.top();
			T dis = p.first; // dis为到当前点的距离
			int pos = p.second; // pos为当前点
			q.pop();
			if (!v[pos]) {
				v[pos] = 1;
				ans += d[pos];
				for (int i = 0; i < G[pos].size(); i++) {
					int x = G[pos][i].first; // x为当前枚举边的终点，
					T y = G[pos][i].second; // y为当前枚举边的权值
					if (!v[x] && d[x] > y) {
						d[x] = y;
						if (!v[x])
							q.push(make_pair(d[x], x));
					}
				}
			}
		}
		return ans;
	}
};

```

### 最小乘积生成树

``` cpp
#include <cstdio>
#include <algorithm>
#include <vector>

inline int read()
{
    int data = 0, w = 1; char ch = getchar();
    while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
    if (ch == '-') w = -1, ch = getchar();
    while (ch >= '0' && ch <= '9') data = data * 10 + (ch ^ 48), ch = getchar();
    return data * w;
}

const int N(205), M(10010);
struct vector { int x, y; }; vector ans = (vector) {(int) 1e9, (int) 1e9};
inline vector operator - (const vector &lhs, const vector &rhs)
    { return (vector) {lhs.x - rhs.x, lhs.y - rhs.y}; }
inline int operator * (const vector &lhs, const vector &rhs)
    { return lhs.x * rhs.y - lhs.y * rhs.x; }
void chkmin(vector &x, vector y)
{
    long long _x = 1ll * x.x * x.y, _y = 1ll * y.x * y.y;
    if (_x > _y || (_x == _y && x.x > y.x)) x = y;
}

int n, m, fa[N], rnk[N];
int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
int merge(int x, int y)
{
    x = find(x), y = find(y);
    return (rnk[x] == rnk[y] ? fa[x] = y, ++rnk[y] :
            (rnk[x] < rnk[y] ? fa[x] = y : fa[y] = x));
}

struct edge { int x, y, a, b, w; } e[M];
inline int operator < (const edge &lhs, const edge &rhs) { return lhs.w < rhs.w; }
vector Kruskal()
{
    vector res = (vector) {0, 0}; int cnt = 0;
    for (int i = 1; i <= n; i++) fa[i] = i, rnk[i] = 1;
    std::sort(e + 1, e + m + 1);
    for (int i = 1; i <= m && cnt < n - 1; i++)
    {
        int x = find(e[i].x), y = find(e[i].y);
        if (x != y) merge(x, y), res.x += e[i].a, res.y += e[i].b, ++cnt;
    }
    return res;
}

void solve(const vector &A, const vector &B)
{
    for (int i = 1; i <= m; i++)
        e[i].w = e[i].a * (A.y - B.y) + e[i].b * (B.x - A.x);
    vector C = Kruskal(); chkmin(ans, C);
    if ((B - A) * (C - A) >= 0) return;
    solve(A, C), solve(C, B);
}

int main()
{
    n = read(), m = read();
    for (int i = 1; i <= m; i++)
        e[i] = (edge) {read() + 1, read() + 1, read(), read(), 0};
    for (int i = 1; i <= m; i++) e[i].w = e[i].a;
    vector A = Kruskal(); chkmin(ans, A);
    for (int i = 1; i <= m; i++) e[i].w = e[i].b;
    vector B = Kruskal(); chkmin(ans, B);
    solve(A, B); printf("%d %d\n", ans.x, ans.y);
    return 0;
}

```



### Matrix Tree 最小生成树计数

``` cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<vector>
#include<cstdio>
#define p 31011
#define N 1003
using namespace std;
int a[12][12],c[N][N],n,m,vis[N],fa[N],U[N];
vector<int> V[N];
struct data{
    int x,y,c;
    bool operator<(const data &a)const{
      return c<a.c;
    }
}e[N];
int gauss(int n)
{
    for (int i=1;i<=n;i++)
     for (int j=1;j<=n;j++) a[i][j]%=p;
    //for (int i=1;i<=n;i++,cout<<endl)
     // for (int j=1;j<=n;j++) cout<<a[i][j]<<" ";
    int ret=1;
    for (int i=1;i<=n;i++) {
        int num=i;
        for (int j=i+1;j<=n;j++)
         if (abs(a[j][i])) num=j;
        for (int j=1;j<=n;j++) swap(a[num][j],a[i][j]);
        if (num!=i) ret=-ret;
        for (int j=i+1;j<=n;j++)
         while (a[j][i]) {
            int t=a[j][i]/a[i][i];
            for (int k=1;k<=n;k++)
             a[j][k]=(a[j][k]-t*a[i][k])%p;
            if (!a[j][i]) break;
            ret=-ret;
            for (int k=1;k<=n;k++) swap(a[i][k],a[j][k]);
         }
        ret=(ret*a[i][i])%p;
    }
    //cout<<ret<<endl;
    return (ret%p+p)%p;
}
int find(int x,int f[N])
{
    if (x==f[x]) return x;
    else return find(f[x],f);
}
int main()
{
    freopen("bzoj_1016.in","r",stdin);
    freopen("bzoj_1016.out","w",stdout);
    scanf("%d%d",&n,&m);
    for (int i=1;i<=m;i++) scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].c);
    sort(e+1,e+m+1);
    for (int i=1;i<=n;i++) vis[i]=0,fa[i]=i;
    int ans=1; int last=-1;
    for (int i=1;i<=m+1;i++) {
        if (e[i].c!=last||i==m+1) {
            for (int j=1;j<=n;j++)
             if (vis[j]) {
                int r1=find(j,U);
                V[r1].push_back(j);
                vis[j]=0;
             }
            for (int j=1;j<=n;j++)
             if (V[j].size()>1) {
                memset(a,0,sizeof(a));
                int len=V[j].size();
                for (int k=0;k<len;k++)
                 for (int l=k+1;l<len;l++) {
                    int x=V[j][k]; int y=V[j][l]; int t=c[x][y];
                    a[k+1][l+1]-=t; a[l+1][k+1]-=t;
                    a[k+1][k+1]+=t; a[l+1][l+1]+=t;
                 }
                ans=ans*gauss(len-1)%p;
                for (int k=0;k<len;k++) fa[V[j][k]]=j;
             }
            for (int j=1;j<=n;j++) {
                U[j]=fa[j]=find(j,fa);
                V[j].clear();
            }
            last=e[i].c;
            if(i==m+1) break;
        }
        int x=e[i].x; int y=e[i].y;
        int r1=find(x,fa); int r2=find(y,fa);
        if (r1==r2) continue;
        U[find(r1,U)]=find(r2,U); vis[r1]=1; vis[r2]=1;
        c[r1][r2]++; c[r2][r1]++;
    }
    int flag=1;
    for (int i=2;i<=n;i++)
     if (find(i,U)!=find(i-1,U)) flag=0;
    ans=(ans*flag%p+p)%p;
    printf("%d\n",ans);
}

```



## ST 表求 LCA

``` cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2000005;
vector <int> g[N];
int n,m,rt,st[N][20],dep[N],dis[N],vis[N],ind,lg2[N],s[N],bg[N],ed[N];

void dfs(int p) {
    vis[p]=1;
    s[++ind]=p;
    bg[p]=ind;
    for(int q:g[p]) {
        if(vis[q]==0) {
            dep[q]=dep[p]+1;
            dfs(q);
            s[++ind]=p;
        }
    }
    ed[p]=ind;
}

int lca(int p,int q) {
    p=bg[p]; q=bg[q];
    if(p>q) swap(p,q);
    int l=lg2[q-p+1];
    int x=st[p][l];
    int y=st[q-(1<<l)+1][l];
    return s[dis[x]<dis[y]?x:y];
}

signed main() {
    ios::sync_with_stdio(false);
    scanf("%d%d%d",&n,&m,&rt);
    for(int i=0;i<=20;i++) for(int j=1<<i;j<1<<(i+1);j++) lg2[j]=i;
    for(int i=1;i<n;i++) {
        int t1,t2;
        scanf("%d%d",&t1,&t2);
        g[t1].push_back(t2);
        g[t2].push_back(t1);
    }
    dfs(rt);
    for(int i=1;i<=ind;i++) dis[i]=dep[s[i]];
    for(int i=1;i<=ind;i++) st[i][0]=i;
    for(int i=1;i<=19;i++) {
        for(int j=1;j<=ind;j++) {
            st[j][i]=dis[st[j][i-1]]<dis[st[j+(1<<(i-1))][i-1]]?
                    st[j][i-1]:st[j+(1<<(i-1))][i-1];
        }
    }
    for(int i=1;i<=m;i++) {
        int t1,t2;
        scanf("%d%d",&t1,&t2);
        printf("%d\n",lca(t1,t2));
    }
}
```





## 最小树形图

``` cpp
// MST for Directed Graph
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
const int N = 100 + 5;
const int M = 10000 + 5;
const ll INF = 0x3f3f3f3f;

int n, m, r;

struct edge {int u, v, w;} e[M];

int fa[N], id[N], top[N], minw[N];

ll get_ans (int n, int m) {
    ll ans = 0;
    while (true) {
        int cnt = 0;
        for (int i = 1; i <= n; ++i) {
            id[i] = top[i] = 0; minw[i] = INF;
        }
        for (int i = 0; i < m; ++i) {
            if (e[i].u != e[i].v && e[i].w < minw[e[i].v]) {
                fa[e[i].v] = e[i].u;
                minw[e[i].v] = e[i].w;
            }
        }
        minw[r] = 0;
        for (int i = 1; i <= n; ++i) {
            if (minw[i] == INF) return -1;
            ans += minw[i];
            int u = i;
            while (u != r && top[u] != i && !id[u]) {
                top[u] = i;
                u = fa[u];
            }
            if (u != r && !id[u]) {
                id[u] = ++cnt;
                for (int v = fa[u]; v != u; v = fa[v]) id[v] = cnt;
            }
        }
        if (cnt == 0) return ans;
        for (int i = 1; i <= n; ++i) {
            if (!id[i]) id[i] = ++cnt;
        }
        for (int i = 0; i < m; ++i) {
            int prew = minw[e[i].v];
            e[i].u = id[e[i].u];
            e[i].v = id[e[i].v];
            if (e[i].u != e[i].v) {
                e[i].w -= prew;
            }
        }
        n = cnt; r = id[r];
    }
}

int main () {
    cin >> n >> m >> r;
    for (int i = 0; i < m; ++i) {
        static int u, v, w;
        cin >> u >> v >> w;
        e[i] = (edge) {u, v, w};
    }
    cout << get_ans (n, m) << endl;
}

```



## 斯坦纳树

``` cpp
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define N 100010
using namespace std;
typedef long long ll;
typedef pair<ll , int> pr;
priority_queue<pr> q;
int head[N] , to[N << 2] , next[N << 2] , cnt , vis[33][N];
ll len[N << 2] , f[33][N];
inline void add(int x , int y , ll z)
{
    to[++cnt] = y , len[cnt] = z , next[cnt] = head[x] , head[x] = cnt;
}
int main()
{
    int n , p , m , i , j , k , x , y;
    ll z , ans = 1ll << 62;
    scanf("%d%d%d" , &n , &p , &m);
    memset(f , 0x3f , sizeof(f));
    for(i = 0 ; i < p ; i ++ ) scanf("%d" , &x) , f[1 << i][x] = 0;
    for(i = 0 ; i < m ; i ++ ) scanf("%d%d%lld" , &x , &y , &z) , add(x , y , z) , add(y , x , z);
    for(i = 1 ; i < (1 << p) ; i ++ )
    {
        for(j = i ; j ; j = i & (j - 1))
            for(k = 1 ; k <= n ; k ++ )
                f[i][k] = min(f[i][k] , f[j][k] + f[i ^ j][k]);
        for(j = 1 ; j <= n ; j ++ ) q.push(pr(-f[i][j] , j));
        while(!q.empty())
        {
            x = q.top().second , q.pop();
            if(vis[i][x]) continue;
            vis[i][x] = 1;
            for(j = head[x] ; j ; j = next[j])
                if(f[i][to[j]] > f[i][x] + len[j])
                    f[i][to[j]] = f[i][x] + len[j] , q.push(pr(-f[i][to[j]] , to[j]));
        }
    }
    for(i = 1 ; i <= n ; i ++ ) ans = min(ans , f[(1 << p) - 1][i]);
    printf("%lld\n" , ans);
    return 0;
}

```



## Euler 回路 (Fleury 算法)

``` cpp
stack<int>S;
int edge[MAXN][MAXN];
int n,m;

void dfs(int x){
    S.push(x);
    for(int i=1;i<=n;i++){
        if(edge[x][i]>0){
            edge[i][x]=edge[x][i]=0;
            dfs(i);
            break;
        }
    }
}

void Fleury(int x){
    S.push(x);
    while(!S.empty()){
        int b=0;
        for(int i=1;i<=n;i++){
            if(edge[S.top()][i]>0){
                b=1;
                break;
            }
        }
        if(b==0){
            printf("%d",S.top());
            S.pop();
        }else {
            int y=S.top();
            S.pop();
            dfs(y);
        }
    }
    printf("\n");
}
```





## 缩点

### 有向图 Tarjan 求强连通分量

``` cpp
namespace scc {
    vector <int> g[N],scc[N];
    int ind,f[N],siz[N],dfn[N],low[N],vis[N],s[N],bel[N],top,tot,n,m,d[N];
    char ch[N];
    void make(int p,int q) {
        d[q]++;
        g[p].push_back(q);
    }
    void dfs(int p) {
        s[++top]=p;
        dfn[p]=low[p]=++ind;
        for(int i=0;i<g[p].size();i++) {
            int q=g[p][i];
            if(!dfn[q]) dfs(q), low[p]=min(low[p],low[q]);
            else if(!bel[q]) low[p]=min(low[p],dfn[q]);
        }
        if(dfn[p]==low[p]) {
            ++tot;
            for(int i=0;i!=p;) {
                i=s[top--];
                bel[i]=tot;
                scc[tot].push_back(i);
            }
        }
    }
    void solve(int _n) {
        n=_n;
        for(int i=1;i<=n;i++) if(!dfn[i]) dfs(i);
    }
}

```



### 无向图 Tarjan 求割点

``` cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 20005;
int num,low[N],dfn[N],cut[N],n,m,ind,t1,t2,t3;
vector <int> g[N];

void dfs(int p,int fa) {
    dfn[p]=low[p]=++ind;
    int c=0;
    for(int q:g[p]) {
        if(!dfn[q]) {
            dfs(q,p);
            low[p]=min(low[p],low[q]);
            if(low[q]>=dfn[p] && fa) cut[p]=1;
            if(!fa) ++c;
        }
        low[p]=min(low[p],dfn[q]);
    }
    if(!fa && c>1) cut[p]=1;
}

signed main() {
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=m;i++) {
        cin>>t1>>t2;
        g[t1].push_back(t2);
        g[t2].push_back(t1);
    }
    for(int i=1;i<=n;i++) if(!dfn[i]) dfs(i,0);
    num=accumulate(cut+1,cut+n+1,0);
    cout<<num<<endl;
    for(int i=1;i<=n;i++) if(cut[i]) cout<<i<<" ";
}
```





## 2-SAT Kosaraju

  现有一个由N个布尔值组成的序列A，给出一些限制关系，比如A[x] AND A[y]=0、A[x] OR A[y] OR A[z]=1等，要确定A[0..N-1]的值，使得其满足所有限制关系。这个称为SAT问题，特别的，若每种限制关系中最多只对两个元素进行限制，则称为2-SAT问题。

由于在2-SAT问题中，最多只对两个元素进行限制，所以可能的限制关系共有11种：
A[x]
NOT A[x]
A[x] AND A[y]
A[x] AND NOT A[y]
A[x] OR A[y]
A[x] OR NOT A[y]
NOT (A[x] AND A[y])
NOT (A[x] OR A[y])
A[x] XOR A[y]
NOT (A[x] XOR A[y])
A[x] XOR NOT A[y]
进一步，A[x] AND A[y]相当于(A[x]) AND (A[y])（也就是可以拆分成A[x]与A[y]两个限制关系），NOT(A[x] OR A[y])相当于NOT A[x] AND NOT A[y]（也就是可以拆分成NOT A[x]与NOT A[y]两个限制关系）。因此，可能的限制关系最多只有9种。

在实际问题中，2-SAT问题在大多数时候表现成以下形式：有N对物品，每对物品中必须选取一个，也只能选取一个，并且它们之间存在某些限制关系（如某两个物品不能都选，某两个物品不能都不选，某两个物品必须且只能选一个，某个物品必选）等，这时，可以将每对物品当成一个布尔值（选取第一个物品相当于0，选取第二个相当于1），如果所有的限制关系最多只对两个物品进行限制，则它们都可以转化成9种基本限制关系，从而转化为2-SAT模型。  

其实2-SAT问题的建模是和实际问题非常相似的。
建立一个2N阶的有向图，其中的点分为N对，每对点表示布尔序列A的一个元素的0、1取值（以下将代表A[i]的0取值的点称为i，代表A[i]的1取值的点称为i'）。显然每对点必须且只能选取一个。然后，图中的边具有特定含义。若图中存在边<i, j>，则表示若选了i必须选j。可以发现，上面的9种限制关系中，后7种二元限制关系都可以用连边实现，比如NOT(A[x] AND A[y])需要连两条边<x, y'>和<y, x'>，A[x] OR A[y]需要连两条边<x', y>和<y', x>。而前两种一元关系，对于A[x]（即x必选），可以通过连边<x', x>来实现，而NOT A[x]（即x不能选），可以通过连边<x, x'>来实现。

这个算法的思想很简单，也比较好写。前提是我们已经熟练掌握了dfs的写法及思想。下面是算法流程：

- 首先我们对原图先进性一边dfs得到原图中各结点的拓扑序把他存在一个数组里。
- 在有了拓扑序后，我们再对原图反向后的图按照逆拓扑序进行dfs每次dfs就得到一个强连通分支。

``` cpp
// INPUT (1e+6 ok)
// [Num of varibles] [Num of conditions]
// [i,a,j,b]  xi=a or xj=b  a,b in {0,1}
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#define reset(a) memset((a),0,sizeof((a)))
using namespace std;
static char buf[100000],*pa,*pd;
#define gc pa==pd&&(pd=(pa=buf)+fread(buf,1,100000,stdin),pa==pd)?EOF:*pa++
inline int read(){
    register int x(0);register char c(gc);
    while(c>'9'||c<'0')c=gc;
    while(c>='0'&&c<='9')x=x*10+c-48,c=gc;
    return x;
}
const int N=4001000;
struct edge{
    int to,next;
}e[N];
int head[N],tot,HEAD[N];
int n,m,cnt,turn[N],belong[N],vis[N];
void add(int x,int y){
    e[++tot].to=y;e[tot].next=head[x];head[x]=tot;
    e[++tot].to=x;e[tot].next=HEAD[y];HEAD[y]=tot;
}
void dfs1(int u){
    int i;
    vis[u]=1;
    for(i=head[u];i;i=e[i].next)
        if(!vis[e[i].to])
            dfs1(e[i].to);
    turn[++cnt]=u;
}
void dfs2(int u){
    belong[u]=cnt;vis[u]=1;
    for(int i=HEAD[u];i;i=e[i].next)
        if(!vis[e[i].to])
            dfs2(e[i].to);
}
void kosaraju(){
    for(int i=1;i<=2*n;i++)
        if(!vis[i])dfs1(i);
    reset(vis);cnt=0;
    for(int i=2*n;i>=1;i--)
        if(!vis[turn[i]])
            cnt++,dfs2(turn[i]);
}
int main(){
    n=read();m=read();
    register int i,x,y,f1,f2;
    for(i=1;i<=m;i++){
        x=read();f1=read();y=read();f2=read();
        add(x+n*(f1&1),y+n*(f2^1));
        add(y+n*(f2&1),x+n*(f1^1));
    }
    kosaraju();
    for(i=1;i<=n;i++)
        if(belong[i]==belong[i+n]){
            cout<<"IMPOSSIBLE";return 0;
        }
    cout<<"POSSIBLE\n";
    for(i=1;i<=n;i++){
        cout<<(belong[i]>belong[i+n])<<' ';
    }
    return 0;
}

```

  【O(NM)算法：求字典序最小的解】
根据2-SAT建成的图中边的定义可以发现，若图中i到j有路径，则若i选，则j也要选；或者说，若j不选，则i也不能选；
因此得到一个很直观的算法：
（1）给每个点设置一个状态V，V=0表示未确定，V=1表示确定选取，V=2表示确定不选取。称一个点是**已确定**的当且仅当其V值非0。设立两个队列Q1和Q2，分别存放本次尝试选取的点的编号和尝试不选的点的编号。
（2）若图中所有的点均已确定，则找到一组解，结束，否则，将Q1、Q2清空，并任选一个未确定的点i，将i加入队列Q1，将i'加入队列Q2；
（3）找到i的所有后继。对于后继j，若j未确定，则将j加入队列Q1；若j'（这里的j'是指与j在同一对的另一个点）未确定，则将j'加入队列Q2；
（4）遍历Q2中的每个点，找到该点的所有前趋（这里需要先建一个补图），若该前趋未确定，则将其加入队列Q2；
（5）在（3）（4）步操作中，出现以下情况之一，则本次尝试失败，否则本次尝试成功：
<1>某个已被加入队列Q1的点被加入队列Q2；
<2>某个已被加入队列Q2的点被加入队列Q1;
<3>某个j的状态为2；
<4>某个i'或j'的状态为1或某个i'或j'的前趋的状态为1；
（6）若本次尝试成功，则将Q1中的所有点的状态改为1，将Q2中所有点的状态改为2，转（2），否则尝试点i'，若仍失败则问题无解。
该算法的时间复杂度为O(NM)（最坏情况下要尝试所有的点，每次尝试要遍历所有的边），但是在多数情况下，远远达不到这个上界。
具体实现时，可以用一个数组vst来表示队列Q1和Q2。设立两个标志变量i1和i2（要求对于不同的i，i1和i2均不同，这样可以避免每次尝试都要初始化一次，节省时间），若vst[i]=i1则表示i已被加入Q1，若vst[i]=i2则表示i已被加入Q2。不过Q1和Q2仍然是要设立的，因为遍历（BFS）的时候需要队列，为了防止重复遍历，加入Q1（或Q2）中的点的vst值必然不等于i1（或i2）。中间一旦发生矛盾，立即中止尝试，宣告失败。

该算法虽然在多数情况下时间复杂度到不了O(NM)，但是综合性能仍然不如下面的O(M)算法。不过，该算法有一个很重要的用处：求字典序最小的解！
如果原图中的同一对点编号都是连续的（01、23、45……）则可以依次尝试第0对、第1对……点，每对点中先尝试编号小的，若失败再尝试编号大的。这样一定能求出字典序最小的解（如果有解的话），因为**一个点一旦被确定，则不可更改**。
如果原图中的同一对点编号不连续（比如03、25、14……）则按照该对点中编号小的点的编号递增顺序将每对点排序，然后依次扫描排序后的每对点，先尝试其编号小的点，若成功则将这个点选上，否则尝试编号大的点，若成功则选上，否则（都失败）无解。  



## 网络流

### Dinic 最大流

``` cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=50005;
const int maxm=500005;
const int inf=0x3f3f3f3f;
struct Node{
    int to,val,next;
}q[maxm<<1];
int head[maxn],cnt=0,dep[maxn],cur[maxn],vis[maxn];
int sp,ep,maxflow;
void init(){
    memset(head,-1,sizeof(head));
    cnt=2,maxflow=0;
}
void addedge(int from,int to,int val){
    q[cnt].to=to;
    q[cnt].val=val;
    q[cnt].next=head[from];
    head[from]=cnt++;
}
void add_edge(int from,int to,int val){
    addedge(from,to,val);
    addedge(to,from,0);
}
bool bfs(int n){
    for(int i=0;i<=n;i++){
        cur[i]=head[i],dep[i]=0x3f3f3f3f;
        vis[i]=0;
    }
    dep[sp]=0;
    queue<int>que;
    que.push(sp);
    while(!que.empty()){
        int x=que.front();
        que.pop();
        vis[x]=0;
        for(int i=head[x];i!=-1;i=q[i].next){
            int to=q[i].to;
            if(dep[to]>dep[x]+1&&q[i].val){
                dep[to]=dep[x]+1;
                if(!vis[to]){
                    que.push(to);
                    vis[to]=1;
                }
            }
        }
    }
    if(dep[ep]!=inf) return true;
    else return false;
}
int dfs(int x,int flow){
    int rlow=0;
    if(x==ep){
        maxflow+=flow;
        return flow;
    }
    int used=0;
    for(int i=cur[x];i!=-1;i=q[i].next){
        cur[x]=i;
        int to=q[i].to;
        if(q[i].val&&dep[to]==dep[x]+1){
            if(rlow=dfs(to,min(flow-used,q[i].val))){
                used+=rlow;
                q[i].val-=rlow;
                q[i^1].val+=rlow;
                if(used==flow) break;
            }
        }
    }
    return used;
}
int dinic(int n){
    while(bfs(n)){
        dfs(sp,inf);
    }
    return maxflow;
}
int main()
{
    int n,m;
    scanf("%d%d%d%d",&n,&m,&sp,&ep);
    register int i;
    int u,v,val;
    init();
    for(i=1;i<=m;i++){
        scanf("%d%d%d",&u,&v,&val);
        add_edge(u,v,val);
    }
    printf("%d",dinic(n));
    return 0;
}

```

### Dinic 最大流 备用

``` cpp
#include <bits/stdc++.h>
using namespace std;
namespace flow {

const int maxn = 200005;
const int inf = 1e+9;

int dis[maxn], ans, cnt = 1, s, t, pre[maxn * 10], nxt[maxn * 10], h[maxn], v[maxn * 10];
std::queue<int> q;
void make(int x, int y, int z) {
    pre[++cnt] = y, nxt[cnt] = h[x], h[x] = cnt, v[cnt] = z;
    pre[++cnt] = x, nxt[cnt] = h[y], h[y] = cnt;
}
bool bfs() {
    memset(dis, 0, sizeof dis);
    q.push(s), dis[s] = 1;
    while (!q.empty()) {
        int x = q.front();
        q.pop();
        for (int i = h[x]; i; i = nxt[i])
            if (!dis[pre[i]] && v[i])
                dis[pre[i]] = dis[x] + 1, q.push(pre[i]);
    }
    return dis[t];
}
int dfs(int x, int flow) {
    if (x == t || !flow)
        return flow;
    int f = flow;
    for (int i = h[x]; i; i = nxt[i])
        if (v[i] && dis[pre[i]] > dis[x]) {
            int y = dfs(pre[i], min(v[i], f));
            f -= y, v[i] -= y, v[i ^ 1] += y;
            if (!f)
                return flow;
        }
    if (f == flow)
        dis[x] = -1;
    return flow - f;
}
int solve(int _s,int _t) {
    s=_s;
    t=_t;
    ans = 0;
    for (; bfs(); ans += dfs(s, inf));
    return ans;
}
}

int n, m, s, t, t1, t2, t3;

int main() {
    cin>>n>>m>>s>>t;
    for(int i=1;i<=m;i++) {
        cin>>t1>>t2>>t3;
        flow::make(t1,t2,t3);
    }
    cout<<flow::solve(s,t);
}

```

### ISAP 最大流

``` cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 16384, MAXN = 262144;
#define reset(x) memset(x,0,sizeof x)
struct graph {
    int n,m,M,S,T,head[N],cur[N],dep[N],gap[N],q[N];
    long long ans;
    struct ed {
        int to,nxt,val;
    } edge[MAXN];
    void init(int n0,int m0,int S0,int T0) {
        n=n0,m=m0,S=S0,T=T0,M=1,reset(gap);
        reset(head),reset(cur),reset(dep),reset(q);
    }
    void make(int u,int v,int w) {
        edge[++M]=(ed) {v,head[u],w},head[u]=M;
    }
    int dfs(int u,int mx) {
        if (u==T)
            return mx;
        int num=0,f;
        for (int &i=cur[u],v; i; i=edge[i].nxt)
            if (dep[v=edge[i].to]==dep[u]-1 && (f=edge[i].val))
                if (edge[i].val-=(f=dfs(v,min(mx-num,f))), edge[i^1].val+=f, (num+=f)==mx)
                    return num;
        if (!--gap[dep[u]++])
            dep[S]=n+1;
        return ++gap[dep[u]],cur[u]=head[u],num;
    }
    void solve() {
        for (int i=1; i<=n; ++i)
            cur[i]=head[i];
        ans=0;
        for (gap[0]=n; dep[S]<=n; ans+=dfs(S,0x7fffffff));
    }
} g;

int n,m,S,T,t1,t2,t3;
int main() {
    scanf("%d%d%d%d",&n,&m,&S,&T);
    g.init(n,m,S,T);
    for (int i=1; i<=m; ++i)
        scanf("%d%d%d",&t1,&t2,&t3),g.make(t1,t2,t3),g.make(t2,t1,0);
    g.solve();
    printf("%lld\n",g.ans);
}

```

### hlpp 最大流

``` cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e3, INF = 2147483647;
struct E {
    int to, flow, back;
};
vector<E> edge[N];
int n, m, s, t, d[N], l[N], v[N], num[N];
priority_queue<pair<int, int> > Q;
inline void push(int x) { Q.push(make_pair(d[x], x)); }
inline int hlpp(int s, int t) {
    d[s] = n;
    l[s] = INF;
    v[s] = 1;
    push(s);
    num[0] = n - 1;
    while (!Q.empty()) {
        int x = Q.top().second;
        Q.pop();
        if (!l[x] || x == t)
            continue;
        vector<E>& e = edge[x];
        for (int i = 0; i < edge[x].size() && l[x]; i++)
            if (e[i].flow && (x == s || d[x] == d[e[i].to] + 1)) {
                int tmp = min(e[i].flow, l[x]);
                if (!tmp)
                    continue;
                if (x != s)
                    l[x] -= tmp;
                l[e[i].to] += tmp;
                e[i].flow -= tmp;
                edge[e[i].to][e[i].back].flow += tmp;
                if (e[i].to != s && !v[e[i].to])
                    v[e[i].to] = 1, push(e[i].to);
            }
        if (x != s && l[x]) {
            if (!--num[d[x]]) {
                int a = d[x];
                for (int i = 1; i <= n; i++)
                    if (d[i] >= a && i != s && i != t)
                        d[i] = n, l[i] = 0;
                continue;
            }
            int tmp = n;
            for (int i = 0; i < edge[x].size(); i++)
                if (e[i].flow)
                    tmp = min(tmp, d[e[i].to] + 1);
            num[d[x] = tmp]++;
            push(x);
        }
        v[x] = 0;
    }
    return l[t];
}
int main() {
    scanf("%d%d%d%d", &n, &m, &s, &t);
    for (int i = 0; i < m; i++) {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        edge[x].push_back((E){ y, z, edge[y].size() });
        edge[y].push_back((E){ x, 0, edge[x].size() - 1 });
    }
    printf("%d\n", hlpp(s, t));
    return 0;
}
```

### Dinic 玄学优化版本

``` cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1305, M = 120005;
struct node {
    int u, v, cap;
} e[M];
int n, m, s, t, ans;
#define pk push_back
struct Dinic {
    int ty, s, t, dis[N], cur[N], que[N];
    vector<node> e;
    vector<int> v[N];
    inline void add(int x, int y, int flow) {
        e.pk((node){ x, y, flow });
        e.pk((node){ y, x, 0 });
        v[x].pk(e.size() - 2);
    }
    inline bool bfs() {
        memset(dis, 0x3f, sizeof(dis));
        int l = 1, r = 1;
        que[1] = s, dis[s] = 0;
        while (l <= r) {
            int p = que[l++], to;
            for (int i : v[p])
                if (e[i].cap && dis[to = e[i].v] > 1e9) {
                    dis[to] = dis[p] + 1, que[++r] = to;
                }
        }
        return dis[t] < 1e9;
    }
    inline int dfs(int p, int a) {
        if (p == t || !a)
            return a;
        int sf = 0, flow;
        for (int &i = cur[p], to; i < (int)v[p].size(); ++i) {
            node& now = e[v[p][i]];
            if (dis[to = now.v] == dis[p] + 1 && (flow = dfs(to, min(a, now.cap)))) {
                now.cap -= flow, e[v[p][i] ^ 1].cap += flow;
                a -= flow, sf += flow;
                if (!a)
                    break;
            }
        }
        return sf;
    }
    inline int dinic(int s, int t, int ty) {
        this->s = s, this->t = t, this->ty = ty;
        int flow = 0;
        while (bfs()) memset(cur, 0, sizeof(cur)), flow += dfs(s, INT_MAX);
        return flow;
    }
} T;
int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> n >> m >> s >> t;
    for (int i = 0; i < m; ++i) cin >> e[i].u >> e[i].v >> e[i].cap;
    sort(e, e + m, [](node x, node y) { return x.cap > y.cap; });
    for (int ty : { 0, 1 })
        for (int p = 1 << 30, i = 0; p; p >>= 1) {
            while (i < m && e[i].cap >= p) {
                if (ty)
                    T.v[e[i].v].pk(i << 1 | 1);
                else
                    T.add(e[i].u, e[i].v, e[i].cap);
                ++i;
            }
            ans += T.dinic(s, t, ty);
        }
    cout << ans << '\n';
    return 0;
}
```



### Dinic + SPFA 费用流

``` cpp
// Init: init() !!!!!
// Input: make(u,v,cap,cost)
// Solver: solve(s,t)
// Output: ans, cost
namespace flow {
const int N = 100005;
const int M = 1000005;
const int inf = 1e+12;
struct Edge {
    int p, c, w, nxt = -1;
} e[N];
int s, t, tans, ans, cost, ind, bus[N], qhead = 0, qtail = -1, qu[M],vis[N], dist[N];

void graph_link(int p, int q, int c, int w) {
    e[ind].p = q;
    e[ind].c = c;
    e[ind].w = w;
    e[ind].nxt = bus[p];
    bus[p] = ind;
    ++ind;
}
void make(int p, int q, int c, int w) {
    graph_link(p, q, c, w);
    graph_link(q, p, 0, -w);
}
int dinic_spfa() {
    qhead = 0;
    qtail = -1;
    memset(vis, 0x00, sizeof vis);
    memset(dist, 0x3f, sizeof dist);
    vis[s] = 1;
    dist[s] = 0;
    qu[++qtail] = s;
    while (qtail >= qhead) {
        int p = qu[qhead++];
        vis[p] = 0;
        for (int i = bus[p]; i != -1; i = e[i].nxt)
            if (dist[e[i].p] > dist[p] + e[i].w && e[i].c > 0) {
                dist[e[i].p] = dist[p] + e[i].w;
                if (vis[e[i].p] == 0)
                    vis[e[i].p] = 1, qu[++qtail] = e[i].p;
            }
    }
    return dist[t] < inf;
}
int dinic_dfs(int p, int lim) {
    if (p == t)
        return lim;
    vis[p] = 1;
    int ret = 0;
    for (int i = bus[p]; i != -1; i = e[i].nxt) {
        int q = e[i].p;
        if (e[i].c > 0 && dist[q] == dist[p] + e[i].w && vis[q] == 0) {
            int res = dinic_dfs(q, min(lim, e[i].c));
            cost += res * e[i].w;
            e[i].c -= res;
            e[i ^ 1].c += res;
            ret += res;
            lim -= res;
            if (lim == 0)
                break;
        }
    }
    return ret;
}
void solve(int _s,int _t) {
    s=_s; t=_t;
    ans = 0;
    cost = 0;
    while (dinic_spfa()) {
        memset(vis, 0x00, sizeof vis);
        ans += dinic_dfs(s, inf);
    }
}
void init() {
    memset(bus, 0xff, sizeof bus); 
    ind=0;
}
}


```

### Gomory-Hu 树

``` cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn=6e2;
const int maxm=2e3;
const int inf=2047483647;

int n,m,q;

inline int read() {
    int a=0;char c=getchar();
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9') a=(a<<1)+(a<<3)+c-'0',c=getchar();
    return a;
}

//for the target graph
int edgeNum,head[maxn],to[maxm<<1],nxt[maxm<<1],w[maxm<<1];

inline void add(int u,int v,int c) {
    nxt[++edgeNum]=head[u];head[u]=edgeNum;
    to[edgeNum]=v;w[edgeNum]=c;
}

int cnt,p[maxn],tmp[maxn],S[maxn];
//cnt stands for the first few Uni-blocks
//p[i] represents the number of the point on the i-th point
//tmp array is used to copy the sort p array
//S[u] indicates the Unicom block number where u is in

struct GHT {
    int s,t,maxFlow,cur[maxn];

    int edgeNum=-1,head[maxn],to[maxm<<1],nxt[maxm<<1];
    int w[maxm<<1],f[maxm<<1];

    GHT() {memset(head,-1,sizeof(head));}

    inline void add_edge(int u,int v,int c) {
        nxt[++edgeNum]=head[u];head[u]=edgeNum;
        to[edgeNum]=v;w[edgeNum]=c;
    }

    int dep[maxn],gap[maxn];

    inline void bfs() {
        memset(dep,0,sizeof(dep));memset(gap,0,sizeof(gap));
        dep[t]=gap[1]=1;queue<int> Q;Q.push(t);
        while(!Q.empty()) { int u=Q.front();Q.pop();
            for(int i=head[u];i!=-1;i=nxt[i]) if(!dep[to[i]])
                ++gap[dep[to[i]]=dep[u]+1],Q.push(to[i]);
        }
    }

    int dfs(int u,int lastFlow) {
        int used=0,minFlow=0;
        if(u==t) {maxFlow+=lastFlow;return lastFlow;}
        for(int &i=cur[u];i!=-1;i=nxt[i])
            if(f[i]&&dep[to[i]]+1==dep[u])
                if(minFlow=dfs(to[i],min(lastFlow-used,f[i])))
                {   f[i]-=minFlow;f[i^1]+=minFlow;
                    if((used+=minFlow)==lastFlow) return used;
                }
        if(!(--gap[dep[u]++])) dep[s]=n+1;
        ++gap[dep[u]];return used;
    }

    inline int ISAP(int x,int y) {
        for(register int i=0;i<=edgeNum;++i) f[i]=w[i];
        maxFlow=0;s=x;t=y;bfs();while(dep[s]<=n) {
            for(register int i=0;i<=n;++i) cur[i]=head[i];
            dfs(s,inf);
        }return maxFlow;
    }

    void dfs(int u) { S[u]=cnt;
        for(int i=head[u];i!=-1;i=nxt[i])
            if(f[i]&&S[to[i]]!=cnt) dfs(to[i]);
    }

    void build(int l,int r) {
        if(l>=r) return ; // Exit with only one point
        int x=p[l],y=p[l+1],cut=ISAP(x,y),L=l,R=r;
        ++cnt;dfs(x);add(x,y,cut);add(y,x,cut);
        for(register int i=l;i<=r;++i) tmp[S[p[i]]==cnt?L++:R--]=p[i];
        for(register int i=l;i<=r;++i) p[i]=tmp[i]; //copy back
        build(l,L-1);build(R+1,r);
    }
}T;

int dep[maxn],fa[maxn][9],Min[maxn][9];

void dfs(int u,int fat) {
    for(register int i=1;i<=8;++i)
        fa[u][i]=fa[fa[u][i-1]][i-1],
        Min[u][i]=min(Min[u][i-1],Min[fa[u][i-1]][i-1]);
    for(int i=head[u];i;i=nxt[i]) if(to[i]!=fat) {
        Min[to[i]][0]=w[i];fa[to[i]][0]=u;
        dep[to[i]]=dep[u]+1;dfs(to[i],u);
    }
}

inline int getCut(int x,int y) {
    int ans=inf;if(dep[x]<dep[y]) x^=y^=x^=y;
    for(register int i=9;i>=0;--i)
        if(dep[fa[x][i]]>=dep[y])
            ans=min(ans,Min[x][i]),x=fa[x][i];
    if(x!=y) {
        for(register int i=9;i>=0;--i)
            if(fa[x][i]!=fa[y][i])
                ans=min(ans,min(Min[x][i],Min[y][i])),
                x=fa[x][i],y=fa[y][i];
        ans=min(ans,min(Min[x][0],Min[y][0]));
    }return ans;
}

int main() {
    n=read();m=read();
    for(register int i=1;i<=n;++i) p[i]=i;
    for(register int i=1;i<=m;++i) {
        int u=read(),v=read(),c=read();
        T.add_edge(u,v,c);T.add_edge(v,u,c);
    }T.build(1,n);dep[1]=1;dfs(1,0);q=read();
    for(register int i=1;i<=q;++i) {
        int u=read(),v=read();
        printf("%d\n",getCut(u,v));
    }return 0;
}

```

## 图的匹配

### 二分图最大匹配 匈牙利算法

``` cpp
#include<cstdio>
#include<vector>
#define N 505
int n,m,p,cx[N],cy[N],vis[N];
std::vector<int> e[N];
int dfs(int u,int Time) {
	for(int i=0;i<(int)e[u].size();++i) {
		int v=e[u][i];
		if(vis[v]^Time) {
			vis[v]=Time;
			if(!cy[v]||dfs(cy[v],Time)) {
				cx[u]=v; cy[v]=u;
				return 1;
			}
		}
	}
	return 0;
}
int main() {
	scanf("%d%d%d",&n,&m,&p);
	while(p--) {
		int u,v;
		scanf("%d%d",&u,&v);
		e[u].push_back(v);
	}
	int ans=0;
	for(int i=1;i<=n;++i) ans+=dfs(i,i);
	printf("%d\n",ans);
	for(int i=1;i<=n;++i) printf("%d ",cx[i]);
	return 0;
}

```

### 二分图最大权匹配 KM算法

``` cpp
// Input: g[v][u] (v in II, u in I)
// Method: solve(n1,n2)
// Output: ans, mat[u] (u in I)
namespace km {
const double inf=1e+9;
const int MX=405;
int n,m;
int py[MX],vy[MX],pre[MX];
double slk[MX],g[MX][MX],kx[MX],ky[MX],ans;
int mat[MX];
void clear() {
    n=m=0;
    reset(py); reset(vy); reset(pre);
    reset(slk); reset(g); reset(kx); reset(ky);
}
void KM(){
	int i,j,k,x,p=0;
	double d,t;
	for(i=1;i<=n;i++)
		for(j=1;j<=n;j++)
			kx[i]=max(kx[i],g[i][j]);
	for(i=1;i<=n;i++){
		memset(vy,0,sizeof(int)*(n+1));
		for(j=0;j<=n;j++) slk[j]=inf;
		memset(pre,0,sizeof(int)*(n+1));
		for(py[k=0]=i;py[k];k=p){
			d=inf;vy[k]=1;x=py[k];
			for(j=1;j<=n;j++)if(!vy[j]){
				if((t=kx[x]+ky[j]-g[x][j])<slk[j])slk[j]=t,pre[j]=k;
				if(slk[j]<d)d=slk[j],p=j;
			}
			for(j=0;j<=n;j++)
                if(vy[j])kx[py[j]]-=d,ky[j]+=d;
                else slk[j]-=d;
		}
		for(;k;k=pre[k])py[k]=py[pre[k]];
	}
}

void solve(int n1,int n2){
	n=max(n1,n2);
	KM();
	ans=0;
	for(int i=1;i<=n;i++)ans+=kx[i]+ky[i];
	for(int i=1;i<=n1;i++)mat[i]=(g[py[i]][i]?py[i]:0);
}
}

```

### 一般图最大匹配 带花树算法

``` cpp
#include<algorithm>
#include<iostream>
using namespace std;
namespace blossom{
const int N=505,M=300005;
int*fr,*bk,que[N],h[N],nxt[M],to[M],ec,match[N],lst[N],vis[N],vcc,n,m,fa[N],col[N],ret;
void add(int u,int v){to[++ec]=v;nxt[ec]=h[u];h[u]=ec;to[++ec]=u;nxt[ec]=h[v];h[v]=ec;}
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
int getlca(int u,int v){
	for(u=find(u),v=find(v),++vcc;;swap(u,v))if(u){
		if(vis[u]==vcc)return u;
		vis[u]=vcc;u=find(lst[match[u]]);
	}
}
void blossom(int u,int v,int lca){
	while(find(u)!=lca){
		if(fa[u]==u)fa[u]=lca;lst[u]=v,v=match[u],u=lst[match[u]];
		if(col[v]==2)col[*bk++=v]=1;if(fa[v]==v)fa[v]=lca;
	}
}
int aug(int x){
	int i;for(i=1;i<=n;i++)fa[i]=i,col[i]=lst[i]=0;
	bk=fr=que,col[*bk++=x]=1;
	while(fr!=bk){
		int u=*fr++,v,z,g;
		for(i=h[u];i;i=nxt[i])if(!col[v=to[i]]){
			lst[v]=u;
			if(!match[v]){for(;u;v=z,u=lst[v])z=match[u],match[u]=v,match[v]=u;return 1;}
			col[v]=2;col[*bk++=match[v]]=1;
		}else if(find(u)!=find(v)&&col[v]==1)g=getlca(u,v),blossom(u,v,g),blossom(v,u,g);
	}
	return 0;
}
void main(){
	int u,v,i;for(cin>>n>>m,i=1;i<=m;i++)cin>>u>>v,add(u,v);
	for(i=1;i<=n;i++)if(!match[i])ret+=aug(i);cout<<ret<<endl;
	for(i=1;i<=n;i++)cout<<match[i]<<" \n"[i==n]; 
}
};
int main(){blossom::main();return 0;}

```

### 一般图最大权匹配 带花树算法

``` cpp
#include<bits/stdc++.h>
#define DIST(e) (lab[e.u]+lab[e.v]-g[e.u][e.v].w*2)
using namespace std;
typedef long long ll;
const int N=1023,INF=1e9;
struct Edge
{
	int u,v,w;
} g[N][N];
int n,m,n_x,lab[N],match[N],slack[N],st[N],pa[N],flower_from[N][N],S[N],vis[N];
vector<int> flower[N];
deque<int> q;
void update_slack(int u,int x)
{
	if(!slack[x]||DIST(g[u][x])<DIST(g[slack[x]][x]))slack[x]=u;
}
void set_slack(int x)
{
	slack[x]=0;
	for(int u=1; u<=n; ++u)
		if(g[u][x].w>0&&st[u]!=x&&S[st[u]]==0)update_slack(u,x);
}
void q_push(int x)
{
	if(x<=n)return q.push_back(x);
	for(int i=0; i<flower[x].size(); i++)q_push(flower[x][i]);
}
void set_st(int x,int b)
{
	st[x]=b;
	if(x<=n)return;
	for(int i=0; i<flower[x].size(); ++i)set_st(flower[x][i],b);
}
int get_pr(int b,int xr)
{
	int pr=find(flower[b].begin(),flower[b].end(),xr)-flower[b].begin();
	if(pr%2==1) //???????????????
	{
		reverse(flower[b].begin()+1,flower[b].end());
		return (int)flower[b].size()-pr;
	}
	else return pr;
}
void set_match(int u,int v)
{
	match[u]=g[u][v].v;
	if(u<=n)return;
	Edge e=g[u][v];
	int xr=flower_from[u][e.u],pr=get_pr(u,xr);
	for(int i=0; i<pr; ++i)set_match(flower[u][i],flower[u][i^1]);
	set_match(xr,v);
	rotate(flower[u].begin(),flower[u].begin()+pr,flower[u].end());
}
void augment(int u,int v)
{
	int xnv=st[match[u]];
	set_match(u,v);
	if(!xnv)return;
	set_match(xnv,st[pa[xnv]]);
	augment(st[pa[xnv]],xnv);
}
int get_lca(int u,int v)
{
	static int t=0;
	for(++t; u||v; swap(u,v))
	{
		if(u==0)continue;
		if(vis[u]==t)return u;
		vis[u]=t;//??????????v??
		u=st[match[u]];
		if(u)u=st[pa[u]];
	}
	return 0;
}
void add_blossom(int u,int lca,int v)
{
	int b=n+1;
	while(b<=n_x&&st[b])++b;
	if(b>n_x)++n_x;
	lab[b]=0,S[b]=0;
	match[b]=match[lca];
	flower[b].clear();
	flower[b].push_back(lca);
	for(int x=u,y; x!=lca; x=st[pa[y]])
		flower[b].push_back(x),flower[b].push_back(y=st[match[x]]),q_push(y);
	reverse(flower[b].begin()+1,flower[b].end());
	for(int x=v,y; x!=lca; x=st[pa[y]])
		flower[b].push_back(x),flower[b].push_back(y=st[match[x]]),q_push(y);
	set_st(b,b);
	for(int x=1; x<=n_x; ++x)g[b][x].w=g[x][b].w=0;
	for(int x=1; x<=n; ++x)flower_from[b][x]=0;
	for(int i=0; i<flower[b].size(); ++i)
	{
		int xs=flower[b][i];
		for(int x=1; x<=n_x; ++x)
			if(g[b][x].w==0||DIST(g[xs][x])<DIST(g[b][x]))
				g[b][x]=g[xs][x],g[x][b]=g[x][xs];
		for(int x=1; x<=n; ++x)
			if(flower_from[xs][x])flower_from[b][x]=xs;
	}
	set_slack(b);
}
void expand_blossom(int b)  // S[b] == 1
{
	for(int i=0; i<flower[b].size(); ++i)
		set_st(flower[b][i],flower[b][i]);
	int xr=flower_from[b][g[b][pa[b]].u],pr=get_pr(b,xr);
	for(int i=0; i<pr; i+=2)
	{
		int xs=flower[b][i],xns=flower[b][i+1];
		pa[xs]=g[xns][xs].u;
		S[xs]=1,S[xns]=0;
		slack[xs]=0,set_slack(xns);
		q_push(xns);
	}
	S[xr]=1,pa[xr]=pa[b];
	for(int i=pr+1; i<flower[b].size(); ++i)
	{
		int xs=flower[b][i];
		S[xs]=-1,set_slack(xs);
	}
	st[b]=0;
}
bool on_found_Edge(const Edge &e)
{
	int u=st[e.u],v=st[e.v];
	if(S[v]==-1)
	{
		pa[v]=e.u,S[v]=1;
		int nu=st[match[v]];
		slack[v]=slack[nu]=0;
		S[nu]=0,q_push(nu);
	}
	else if(S[v]==0)
	{
		int lca=get_lca(u,v);
		if(!lca)return augment(u,v),augment(v,u),1;
		else add_blossom(u,lca,v);
	}
	return 0;
}
bool matching()
{
	fill(S,S+n_x+1,-1),fill(slack,slack+n_x+1,0);
	q.clear();
	for(int x=1; x<=n_x; ++x)
		if(st[x]==x&&!match[x])pa[x]=0,S[x]=0,q_push(x);
	if(q.empty())return 0;
	for(;;)
	{
		while(q.size())
		{
			int u=q.front();
			q.pop_front();
			if(S[st[u]]==1)continue;
			for(int v=1; v<=n; ++v)
				if(g[u][v].w>0&&st[u]!=st[v])
				{
					if(DIST(g[u][v])==0)
					{
						if(on_found_Edge(g[u][v]))return 1;
					}
					else update_slack(u,st[v]);
				}
		}
		int d=INF;
		for(int b=n+1; b<=n_x; ++b)
			if(st[b]==b&&S[b]==1)d=min(d,lab[b]/2);
		for(int x=1; x<=n_x; ++x)
			if(st[x]==x&&slack[x])
			{
				if(S[x]==-1)d=min(d,DIST(g[slack[x]][x]));
				else if(S[x]==0)d=min(d,DIST(g[slack[x]][x])/2);
			}
		for(int u=1; u<=n; ++u)
		{
			if(S[st[u]]==0)
			{
				if(lab[u]<=d)return 0;
				lab[u]-=d;
			}
			else if(S[st[u]]==1)lab[u]+=d;
		}
		for(int b=n+1; b<=n_x; ++b)
			if(st[b]==b)
			{
				if(S[st[b]]==0)lab[b]+=d*2;
				else if(S[st[b]]==1)lab[b]-=d*2;
			}
		q.clear();
		for(int x=1; x<=n_x; ++x)
			if(st[x]==x&&slack[x]&&st[slack[x]]!=x&&DIST(g[slack[x]][x])==0)
				if(on_found_Edge(g[slack[x]][x]))return 1;
		for(int b=n+1; b<=n_x; ++b)
			if(st[b]==b&&S[b]==1&&lab[b]==0)expand_blossom(b);
	}
	return 0;
}
pair<ll,int> weight_blossom()
{
	fill(match,match+n+1,0);
	n_x=n;
	int n_matches=0;
	ll tot_weight=0;
	for(int u=0; u<=n; ++u)st[u]=u,flower[u].clear();
	int w_max=0;
	for(int u=1; u<=n; ++u)
		for(int v=1; v<=n; ++v)
		{
			flower_from[u][v]=(u==v?u:0);
			w_max=max(w_max,g[u][v].w);
		}
	for(int u=1; u<=n; ++u)lab[u]=w_max;
	while(matching())++n_matches;
	for(int u=1; u<=n; ++u)
		if(match[u]&&match[u]<u)
			tot_weight+=g[u][match[u]].w;
	return make_pair(tot_weight,n_matches);
}
int main()
{
	cin>>n>>m;
	for(int u=1; u<=n; ++u)
		for(int v=1; v<=n; ++v)
			g[u][v]=Edge {u,v,0};
	for(int i=0,u,v,w; i<m; ++i)
	{
		cin>>u>>v>>w;
		g[u][v].w=g[v][u].w=w;
	}
	cout<<weight_blossom().first<<'\n';
	for(int u=1; u<=n; ++u)cout<<match[u]<<' ';
}


```



## 支配树

求有向图的支配树： Tarjan

问题：我们有一个有向图(可以有环)，定下了一个节点为起点s。现在我们要求：从起点s出发，走向一个点p的所有路径中，必须要经过的点有哪些{xp}。

换言之，删掉{xp}中的任意一个点xpi以及它的入边出边，都会使s无法到达p。

我们有一种显然的O(nm)的方法：枚举+BFS。

现在我们学习构造图的支配树，它是一种复杂度更优秀的做法。

性质：

1. 它是一棵树(这不废话)，根节点是我们选定的起点s。
2. 对于每个点i，它到根的链上的点集就是对于它的必经点集{xi}。
3. 对于每个点i，它是它的支配树上的子树内的点的必经点。

所以对于上面的问题，把支配树抠出来就可以了。

``` cpp
// Tarjan's algorithm to generate Dominator Tree
//  warning: this algorithm is for normal directed graph 
#include<bits/stdc++.h>
using namespace std;

const int N=2e5+5;
int n,m;
struct node{
    vector<int>edge[N];
    inline void add(int u,int v){edge[u].push_back(v);}
}a,b,c,d;
int dfn[N],id[N],fa[N],cnt;
void dfs(int u){
    dfn[u]=++cnt;id[cnt]=u;
    int len=a.edge[u].size();
    for(int i=0;i<len;++i){
        int v=a.edge[u][i];
        if(dfn[v])continue;
        fa[v]=u;dfs(v);
    }
}
int semi[N],idom[N],bel[N],val[N];
inline int find(int x){
    if(x==bel[x])return x;
    int tmp=find(bel[x]);
    if(dfn[semi[val[bel[x]]]]<dfn[semi[val[x]]]) val[x]=val[bel[x]];
    return bel[x]=tmp;
}
inline void tarjan(){
    for(int i=cnt;i>1;--i){
        int u=id[i],len=b.edge[u].size();
        for(int i=0;i<len;++i){
            int v=b.edge[u][i];
            if(!dfn[v])continue;
            find(v);
            if(dfn[semi[val[v]]]<dfn[semi[u]]) semi[u]=semi[val[v]];
        }
        c.add(semi[u],u);
        bel[u]=fa[u];
        u=fa[u];
        len=c.edge[u].size();
        for(int i=0;i<len;++i){
            int v=c.edge[u][i];
            find(v);
            if(semi[val[v]]==u)idom[v]=u;
            else idom[v]=val[v];
        }
    }
    for(int i=2;i<=cnt;++i){
        int u=id[i];
        if(idom[u]!=semi[u]) idom[u]=idom[idom[u]];
    }
}
int ans[N];
void dfs_ans(int u){
    ans[u]=1;
    int len=d.edge[u].size();
    for(int i=0;i<len;++i){
        int v=d.edge[u][i];
        dfs_ans(v);
        ans[u]+=ans[v];
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;++i){
    	int u,v;
        scanf("%d%d",&u,&v);
        // pay attention to the order
        a.add(u,v);
        b.add(v,u);
    }
    for(int i=1;i<=n;++i) semi[i]=bel[i]=val[i]=i;
    dfs(1);//root id
    tarjan();
    for(int i=2;i<=n;++i) d.add(idom[i],i);//make dominator tree
    dfs_ans(1);
    for(int i=1;i<=n;++i)printf("%d ",ans[i]);
}

```

几种特殊情况

先来看一下两种比较简单的情况。不妨假设从s出发可以到达图的所有点，不失一般性。

**树**

显而易见的，树就是自己的支配树……

**有向无环图(DAG)**

DAG上的问题当然要靠拓扑序来搞！

我们利用拓扑序做。对于一个点，所有能到达它的点在支配树中的lca，就是它支配树中的父亲。

用倍增求lca可以做到O(nlogn)。

比如说 [ZJOI2012 灾难](http://www.lydsy.com/JudgeOnline/problem.php?id=2815)

答案就是支配树上的size。

当时这道题好像也挺难……谁能想到新建树啊……



## 基环树与仙人掌

### 基环树直径

``` cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int N = 1e6+5;

int n,m,t1,t2,t3;
int used[N],vis[N];
vector <pair<signed,signed> > g[N];
vector <pair<signed,signed> > sta;
int cir[N],sum[N],tot,f[N],res;

void dfs(signed p,signed fa,signed fadis)
{
    vis[p]=1;
    sta.push_back({p,fadis});
    for(pair<signed,signed> pr:g[p])
    {
        if(tot) break;
        int q=pr.first, w=pr.second;
        if(q==fa)
        {
            fa=-fa;
            continue;
        }
        if(vis[q])
        {
            tot=1;
            cir[tot]=q;
            sum[tot]=w;
            while(sta.size() && sta.back().first!=q)
            {
                ++tot;
                cir[tot]=sta.back().first;
                sum[tot]=sta.back().second;
                sta.pop_back();
            }
        }
        else
        {
            dfs(q,p,w);
        }
    }
    if(tot==0) sta.pop_back();
}

void dp(int p)
{
    used[p]=1;
    for(pair<signed,signed> pr:g[p])
    {
        int q=pr.first, w=pr.second;
        if(used[q]==0)
        {
            dp(q);
            res=max(res,f[p]+f[q]+w);
            f[p]=max(f[p],f[q]+w);
        }
    }
}

signed main()
{
    ios::sync_with_stdio(false);
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>t2>>t3;
        t1=i;
        g[t1].push_back({t2,t3});
        g[t2].push_back({t1,t3});
    }

    int ans=0;
    for(int i=1;i<=n;i++)
    {
        if(used[i]==0)
        {
            int m1=-1e18, m2=-1e18;
            res=0, tot=0;
            dfs(i,0,0);

            rotate(sum+1,sum+tot,sum+tot+1);

            for(int i=1;i<=tot;i++)
            {
                used[cir[i]]=1;
                sum[i]+=sum[i-1];
            }
            for(int i=1;i<=tot;i++)
            {
                dp(cir[i]);
            }
            for(int i=1;i<=tot;i++)
            {
                res=max(res, max(sum[i]+f[cir[i]]+m1, sum[tot]-sum[i]+f[cir[i]]+m2));
                m1=max(m1, f[cir[i]]-sum[i]);
                m2=max(m2, f[cir[i]]+sum[i]);
            }
            ans+=res;
        }
    }
    cout<<ans;
}
```



### 仙人掌静态询问最短路

``` cpp
// We have a cactus G=(V,E), where |V|=n, |E|=m
// We have q queries. Each as (u,v), querying the SP between u and v.
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define RG register
#define MAX 20000
inline int read()
{
    RG int x=0,t=1;RG char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
struct Line{int v,next,w;};
struct Link
{
    Line e[111111];
    int h[MAX],cnt;
    inline void Add(int u,int v,int w)
    {
        e[++cnt]=(Line){v,h[u],w};h[u]=cnt;
        e[++cnt]=(Line){u,h[v],w};h[v]=cnt;
    }
}T,G;
int n;
struct RST
{
    int fa[MAX],size[MAX],hson[MAX],top[MAX],dep[MAX],dis[MAX];
    int dfn[MAX],tim,ln[MAX],cir[MAX];
    bool zn[MAX];
    void dfs1(int u,int ff)
    {
        fa[u]=ff;size[u]=1;dep[u]=dep[ff]+1;
        for(int i=T.h[u];i;i=T.e[i].next)
        {
            int v=T.e[i].v;if(v==ff)continue;
            dis[v]=dis[u]+T.e[i].w;
            dfs1(v,u);size[u]+=size[v];
            if(size[v]>size[hson[u]])hson[u]=v;
        }
    }
    void dfs2(int u,int tp)
    {
        top[u]=tp;dfn[u]=++tim,ln[tim]=u;
        if(hson[u])dfs2(hson[u],tp);
        for(int i=T.h[u];i;i=T.e[i].next)
            if(T.e[i].v!=fa[u]&&T.e[i].v!=hson[u])
                dfs2(T.e[i].v,T.e[i].v);
    }
    int LCA(int u,int v)
    {
        while(top[u]^top[v])dep[top[u]]<dep[top[v]]?v=fa[top[v]]:u=fa[top[u]];
        return dep[u]<dep[v]?u:v;
    }
    int Jump(int u,int LCA)
    {
        int ret;
        while(top[u]!=top[LCA])
            ret=top[u],u=fa[top[u]];
        return u==LCA?ret:ln[dfn[LCA]+1];
    }
    int Query(int u,int v)
    {
        int lca=LCA(u,v);
        if(lca<=n)return dis[u]+dis[v]-2*dis[lca];
        int uu=Jump(u,lca),vv=Jump(v,lca);
        int d1=dis[uu]-dis[lca],d2=dis[vv]-dis[lca];
        if(!zn[uu])d1=cir[lca]-d1;if(!zn[vv])d2=cir[lca]-d2;
        return dis[u]-dis[uu]+dis[v]-dis[vv]+min(abs(d1-d2),cir[lca]-abs(d1-d2));
    }
}RST;
int dfn[MAX],low[MAX],tim,tp[MAX],dep[MAX];
int fa[MAX];
ll dis[MAX];
int S[MAX],tot,m,Q;
void Build(int u,int y,int d)
{
    int top=dep[y]-dep[u]+1,sum=d,Dis=0;
    for(int i=y;i!=u;i=fa[i])S[top--]=i,sum+=dis[i]-dis[fa[i]];
    ++tot;S[1]=u;top=dep[y]-dep[u]+1;RST.cir[tot]=sum;
    for(int i=1;i<=top;++i)
    {
        int D=min(Dis,sum-Dis);
        T.Add(tot,S[i],D);
        RST.zn[S[i]]=(D==Dis);
        Dis+=dis[S[i+1]]-dis[S[i]];
    }
}
void Tarjan(int u,int ff)
{
    dfn[u]=low[u]=++tim;dep[u]=dep[ff]+1;fa[u]=ff;
    for(int i=G.h[u];i;i=G.e[i].next)
    {
        int v=G.e[i].v;if(v==ff)continue;
        if(!dfn[v])
        {
            dis[v]=dis[u]+G.e[i].w;
            Tarjan(v,u);low[u]=min(low[u],low[v]);
        }
        else low[u]=min(low[u],dfn[v]);
        if(dfn[u]<low[v])T.Add(u,v,G.e[i].w);
    }
    for(int i=G.h[u];i;i=G.e[i].next)
    {
        int v=G.e[i].v;if(v==ff)continue;
        if(fa[v]!=u&&dfn[u]<dfn[v])Build(u,v,G.e[i].w);
    }
}
int main()
{
    tot=n=read();m=read();Q=read();G.cnt=1;
    for(int i=1;i<=m;++i)
    {
        int u=read(),v=read(),w=read();
        G.Add(u,v,w);
    }
    Tarjan(1,0);
    RST.dfs1(1,0);RST.dfs2(1,1);
    while(Q--)printf("%d\n",RST.Query(read(),read()));
    return 0;
}

```



## 树链剖分

``` cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int N = 400005;

int val[N],tag[N];

void pushup(int p) {
    val[p]=val[p*2]+val[p*2+1];
}
void pushdown(int p,int l,int r) {
    if(tag[p]) {
        val[p*2]+=tag[p]*((l+r)/2-l+1);
        val[p*2+1]+=tag[p]*(r-(l+r)/2);
        tag[p*2]+=tag[p];
        tag[p*2+1]+=tag[p];
        tag[p]=0;
    }
}
void build(int p,int l,int r,int *src) {
    if(l==r) val[p]=src[l];
    else {
        build(p*2,l,(l+r)/2,src);
        build(p*2+1,(l+r)/2+1,r,src);
        pushup(p);
    }
}
void modify(int p,int l,int r,int ql,int qr,int key) {
    if(l>qr || r<ql) return;
    if(l>=ql && r<=qr) {
        val[p]+=(r-l+1)*key;
        tag[p]+=key;
    }
    else {
        pushdown(p,l,r);
        modify(p*2,l,(l+r)/2,ql,qr,key);
        modify(p*2+1,(l+r)/2+1,r,ql,qr,key);
        pushup(p);
    }
}
int query(int p,int l,int r,int ql,int qr) {
    if(l>qr || r<ql) return 0;
    if(l>=ql && r<=qr) {
        return val[p];
    }
    else {
        pushdown(p,l,r);
        return query(p*2,l,(l+r)/2,ql,qr)+query(p*2+1,(l+r)/2+1,r,ql,qr);
    }
}

vector <int> g[N];

int top[N],wson[N],siz[N],dep[N],vis[N],tid[N],did[N],fin[N],fa[N],cnt=0;

void link(int p,int q) {
    g[p].push_back(q);
    g[q].push_back(p);
}

void dfs1(int p) {
    vis[p]=siz[p]=1;
    for(int q:g[p]) if(vis[q]==0) {
        dep[q]=dep[p]+1;
        fa[q]=p;
        dfs1(q);
        siz[p]+=siz[q];
        if(siz[q]>siz[wson[p]]) wson[p]=q;
    }
}

void dfs2(int p) {
    did[p]=++cnt;
    tid[cnt]=p;
    vis[p]=1;
    if(wson[p]) top[wson[p]]=top[p],dfs2(wson[p]);
    for(int q:g[p]) if(vis[q]==0) {
        top[q]=q;
        dfs2(q);
    }
    fin[p]=cnt;
}

int n,m,r,mod,v[N],w[N];

void presolve() {
    dep[r]=1;
    dfs1(r);
    memset(vis,0,sizeof vis);
    top[r]=r;
    dfs2(r);
}



void link_modify(int p,int q,int v) {
    while(top[p]-top[q]) {
        if(dep[top[p]]>dep[top[q]]) swap(p,q);
        modify(1,1,n,did[top[q]],did[q],v);
        q=fa[top[q]];
    }
    if(dep[p]>dep[q]) swap(p,q);
    modify(1,1,n,did[p],did[q],v);
}

int link_query(int p,int q) {
    int ans=0;
    while(top[p]-top[q]) {
        if(dep[top[p]]>dep[top[q]]) swap(p,q);
        ans+=query(1,1,n,did[top[q]],did[q]);
        q=fa[top[q]];
    }
    if(dep[p]>dep[q]) swap(p,q);
    ans+=query(1,1,n,did[p],did[q]);
    return ans;
}

signed main() {
    ios::sync_with_stdio(false);
    cin>>n>>m>>r>>mod;
    for(int i=1;i<=n;i++) cin>>v[i];
    for(int i=1;i<n;i++) {
        int t1,t2;
        cin>>t1>>t2;
        link(t1,t2);
    }
    presolve();
    for(int i=1;i<=n;i++) w[did[i]]=v[i];
    build(1,1,n,w);
    for(int i=1;i<=m;i++) {
        int t1,t2,t3,t4;
        cin>>t1;
        if(t1==1) {
            cin>>t2>>t3>>t4;
            link_modify(t2,t3,t4);
        }
        if(t1==2) {
            cin>>t2>>t3;
            cout<<link_query(t2,t3)%mod<<endl;
        }
        if(t1==3) {
            cin>>t2>>t3;
            modify(1,1,n,did[t2],fin[t2],t3);
        }
        if(t1==4) {
            cin>>t2;
            cout<<query(1,1,n,did[t2],fin[t2])%mod<<endl;
        }
    }
}
```





## 点分治

``` cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define foradj(p) for(pair<int,int> pr:g[p])
#define unpii(q,w) int q=pr.first, w=pr.second;
const int N = 1000005;

vector <pair<int,int> > g[N];
int dis[N],siz[N],n,m,t1,t2,t3,k[N],ans[N],vis[N],sum,rt,rtval;
vector<int> st,wl;
set<int> s;

void findroot(int p,int ff)
{
    siz[p]=1;
    int mx=0;
    foradj(p)
    {
        unpii(q,w);
        if(!vis[q] && q!=ff)
        {
            findroot(q,p);
            siz[p]+=siz[q];
            mx=max(mx,siz[q]);
        }
    }
    mx=max(mx,sum-siz[p]);
    if(mx<rtval) rtval=mx, rt=p;
}

void dfs(int p,int ff)
{
    for(int i=1;i<=m;i++)
    {
        ans[i]|=s.count(k[i]-dis[p]);
        st.push_back(dis[p]);
    }
    foradj(p)
    {
        unpii(q,w);
        if(!vis[q] && q!=ff)
        {
            dis[q]=dis[p]+w;
            dfs(q,p);
        }
    }
}

void solve(int p)
{
    vis[p]=1;
    s.clear();
    foradj(p)
    {
        unpii(q,w);
        if(!vis[q])
        {
            dis[q]=w;
            dfs(q,p);
            for(int i:st) s.insert(i);
            st.clear();
        }
    }
    for(int i=1;i<=m;i++)
    {
        ans[i]|=s.count(k[i]);
    }
    foradj(p)
    {
        unpii(q,w);
        if(!vis[q])
        {
            sum=siz[q];
            rtval=1e18;
            findroot(q,0);
            solve(rt);
        }
    }
}

signed main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<n;i++)
    {
        cin>>t1>>t2>>t3;
        g[t1].push_back({t2,t3});
        g[t2].push_back({t1,t3});
    }
    for(int i=1;i<=m;i++)
    {
        cin>>k[i];
    }
    sum=n;
    rtval=1e18;
    findroot(1,0);
    solve(rt);
    for(int i=1;i<=m;i++)
    {
        if(ans[i] || !k[i]) cout<<"Yes"<<endl;
        else cout<<"No"<<endl;
    }
}
```







