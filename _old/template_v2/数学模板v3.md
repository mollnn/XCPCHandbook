[TOC]





# 数论

## GCD

### 扩展欧几里得

``` cpp
inline void exgcd(int a,int b,int &x,int &y) {
    if(!b) {
        x=1,y=0;
        return;
    }
    exgcd(b,a%b,x,y);
    int t=x;
    x=y,y=t-(a/b)*y;
}
```

### GCD Batch

``` cpp
// Fast GCD (n,v)
// presolve: O(v)
// query: O(1)
// 5 seconds used when n=5000 (full query) and v=1e+6
#include <bits/stdc++.h>
using namespace std;
const int mod = 998244353;
const int maxn = 5000, v = 1000000, radio = 1000;
int a[maxn + 10], b[maxn + 10], n, ans;
int np[v + 10], prime[v + 10], cnt;
int k[v + 10][3];
int _gcd[radio + 10][radio + 10];
inline int gcd(int a, int b) {
    int g = 1;
    for(int tmp, i = 0; i < 3; i++) {
        if(k[a][i] > radio) {
            if(b % k[a][i] == 0) tmp = k[a][i];
            else tmp = 1;
        }
        else tmp = _gcd[k[a][i]][b % k[a][i]];
        b /= tmp;
        g *= tmp;
    }
    return g;
}
int main() {
    // Presolve
    k[1][0] = k[1][1] = k[1][2] = 1;
    np[1] = 1;
    for(int i = 2; i <= v; i++) {
        if(!np[i]) prime[++cnt] = i, k[i][2] = i, k[i][1] = k[i][0] = 1;
        for(int j = 1; prime[j] * i <= v; j++) {
            np[i * prime[j]] = 1;
            int *tmp = k[i * prime[j]];
            tmp[0] = k[i][0] * prime[j];
            tmp[1] = k[i][1];
            tmp[2] = k[i][2];
            if(tmp[1] < tmp[0]) swap(tmp[1], tmp[0]);
            if(tmp[2] < tmp[1]) swap(tmp[2], tmp[1]);
            if(i % prime[j] == 0) break;
        }
    }
    for(int i = 1; i <= radio; i++) _gcd[i][0] = _gcd[0][i] = i;
    for(int _max = 1; _max <= radio; _max++)
        for(int i = 1; i <= _max; i++)
            _gcd[i][_max] = _gcd[_max][i] = _gcd[_max % i][i];
    // Test A
    // for(int i = 1; i <= 10; i++)
        // for(int j = 1; j <= 10; j++) printf("gcd(%d, %d) = %d\n", i, j, _gcd[i][j]);
    // Test B
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) scanf("%d", a + i);
    for(int i = 1; i <= n; i++) scanf("%d", b + i);
    for(int i = 1; i <= n; i++) {
        int now = 1, ans = 0;
        for(int j = 1; j <= n; j++) {
            now = 1ll * now * i % mod;
            ans = (ans + 1ll * gcd(a[i], b[j]) * now) % mod;
        }
        printf("%d\n", ans);
    }
    return 0;
}
```



## 逆元

### EXGCD求逆元

``` cpp
inline int inv(int a,int b) {
    int x,y;
    return exgcd(a,b,x,y),(x%b+b)%b;
}
```

### 线性预处理逆元

``` cpp
inv[1]=1;
for(int i=2;i<=n;i++)
    inv[i]=-(p/i)*inv[p%i],
	inv[i]=(inv[i]%p+p)%p;
```



## 筛法

### 线性筛素数

``` cpp
const int MAXN = 20000005;
int prime[MAXN+1]; // Note: Let prime[0] donate the number of primes
// Note: the array "prime" has two different roles in the algorithm
void presolve() {
    memset(prime,0,sizeof prime);
    for(int i=2;i<=MAXN;i++) {
        if(!prime[i]) prime[++prime[0]]=i;
        for(int j=1;j<=prime[0]&&prime[j]<=MAXN/i;j++) {
            prime[prime[j]*i]=1;
            if(i%prime[j]==0) break;
        }
    }
}
```

### 欧拉筛（预处理 $\mu$ 和 $\varphi$ ）

``` cpp
bool isNotPrime[N + 5];
int mu[N + 5], phi[N + 5], primes[N + 5], cnt, sum[N+5];
inline void euler() {
    isNotPrime[0] = isNotPrime[1] = true;
    mu[1] = 1;
    phi[1] = 1;
    for (int i = 2; i <= N; i++) {
        if (!isNotPrime[i]) {
            primes[++cnt] = i;
            mu[i] = -1;
            phi[i] = i - 1;
        }
        for (int j = 1; j <= cnt; j++) {
            int t = i * primes[j];
            if (t > N) break;
            isNotPrime[t] = true;
            if (i % primes[j] == 0) {
                mu[t] = 0;
                phi[t] = phi[i] * primes[j];
                break;
            } else {
                mu[t] = -mu[i];
                phi[t] = phi[i] * (primes[j] - 1);
            }
        }
    }
}
```



### 杜教筛

杜教筛用来求一类**积性函数**的前缀和，利用数论分块的思想来降低复杂度

假设我们现在要求 $S(n) = \sum_{i = 1}^n f(i)$ ，$f(i)$ 为积性函数, $n \leqslant 10^{12}$ ，假设有另一个积性函数 $g$。我们来求它们狄利克雷卷积的前缀和
$$
\begin{aligned}
&\sum_{i = 1}^n (g * f) = \sum_{i = 1}^n \sum_{d \mid i} g(d) f(\frac{i}{d})
\\
=& \sum_{d = 1}^n g(d) \sum_{d|i} f(\frac{i}{d})
\\
=& \sum_{d = 1}^n g(d) \sum_{i = 1}^{\frac{n}{d}}f(i)
\\
=& \sum_{d = 1}^n g(d) S(\frac{n}{d})
\end{aligned}
$$
容斥处理一下，得到
$$
g(1)S(n) = \sum_{d = 1}^n g(d)S(\frac{n}{d}) - \sum_{d = 2}^n g(d)S(\frac{n}{d})
$$
至于 $g$ 的选择，需要看具体情况

| 原函数 $f(n)$       | 选取的函数 $g(n)$ | 递归式                                                       |
| ------------------- | ----------------- | ------------------------------------------------------------ |
| $\mu(n)$            | $1$               | $S(n) = 1 - \sum_{d = 2}^n S(\frac{n}{d})$                   |
| $\varphi(n)$        | $1$               | $S(n) = \frac{n  (n + 1)}{2} - \sum_{d = 2}^n S(\frac{n}{d})$ |
| $n\cdot \varphi(n)$ |                   | $S(n)=\sum_{i=1}^{n}i^2-\sum_{d=2}^{n}d\cdot S(\lfloor\frac{n}{d}\rfloor)$ |

注意询问数量较多时可以采用 `unordered_map` 做记忆化来加速。

``` cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int N = 7.5e6+5;
map<signed,int> mp,mm;
bool isNotPrime[N + 5];
int mu[N + 5], phi[N + 5];
signed primes[N + 5], cnt;
inline void euler() {
    isNotPrime[0] = isNotPrime[1] = true;
    mu[1] = 1;
    phi[1] = 1;
    for (int i = 2; i <= N; i++) {
        if (!isNotPrime[i]) {
            primes[++cnt] = i;
            mu[i] = -1;
            phi[i] = i - 1;
        }
        for (int j = 1; j <= cnt; j++) {
            int t = i * primes[j];
            if (t > N) break;
            isNotPrime[t] = true;
            if (i % primes[j] == 0) {
                mu[t] = 0;
                phi[t] = phi[i] * primes[j];
                break;
            } else {
                mu[t] = -mu[i];
                phi[t] = phi[i] * (primes[j] - 1);
            }
        }
    }
}

int Mu(int n) {
    if(n<=N) return mu[n];
    if(mm[n]) return mm[n];
    register signed l=2,r;
    int ans=1;
    while(l<=n) {
        r=n/(n/l);
        ans-=(r-l+1)*Mu(n/l);
        l=r+1;
    }
    mm[n]=ans;
    return ans;
}

int Phi(int n) {
    if(n<=N) return phi[n];
    if(mp[n]) return mp[n];
    register signed l=2,r;
    int ans=n*(n+1)/2;
    while(l<=n) {
        r=n/(n/l);
        ans-=(r-l+1)*Phi(n/l);
        l=r+1;
    }
    mp[n]=ans;
    return ans;
}

signed main() {
    ios::sync_with_stdio(false);
    euler();
    for(int i=1;i<=N;i++) mu[i]+=mu[i-1], phi[i]+=phi[i-1];
    int n,t;
    cin>>n;
    while(n--) {
        cin>>t;
        cout<<Phi(t)<<" "<<Mu(t)<<endl;
    }
}

```



## 欧拉定理

$(a,m)=1$ 时， $a^{\varphi(m)}=1 \mod m$

**扩展欧拉定理**

$b \geq \varphi(m)$ 时， $a^b = a^{(b \mod \varphi(m))+\varphi(m)} \mod m$ 





## 中国剩余定理

朴素的中国剩余定理解同余方程组，要求为模数两两互质！

设 $m_1, m_2, \cdots, m_n$ 是两两互质的整数，$m = \prod_{i = 1}^nm_i, M_i = m / m_i ，t_i $是线性同余方程 $M_it_i = 1 \pmod m_i$ 的一个解，对于任意的 $n$ 个数 $a_1, a_2, \cdots, a_n$， 方程组 $x = a_i \pmod m_i$ 有整数解，解为 $x = \sum_{i = 1}^na_iM_it_i$

**证明**  因为 $M_i = m / m_i$ 是除 $m_i$ 外所有数的倍数，所以 $\forall k \not= i, a_iM_it_i = 0 \pmod m_k$, 又因为 $a_iM_it_i = a_i \pmod m_i$ 所以带入 $x$， 原方程成立

```cpp
// Parameter: N
// Input: a[] b[] // x=b(mod a)
// Method: china()
// Output: (returned)
namespace crt {
const int N=15;
int n;
int a[N],b[N];
int exgcd(int a,int b,int &x,int &y) {
    if(!b) {
        x=1;y=0;
        return a;
    }
    int q=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return q;
}
int china() {
    int M,res;
    M=1;res=0;
    for(int i=1;i<=n;i++) M*=a[i];
    for(int i=1;i<=n;i++) {
        int m,p,d,y;
        m=M/a[i];d=exgcd(m,a[i],p,y);
        res=(res+m*p*b[i])%M;
    }
    if(res<0) res+=M;
    return res;
}
}

signed main() {
    scanf("%lld",&crt::n);
    for(int i=1;i<=crt::n;i++) scanf("%lld%lld",&crt::a[i],&crt::b[i]);
    printf("%lld",crt::china());
}

/*
3
3 1
5 1
7 2
---
16
*/

```



### 扩展中国剩余定理

不要求模数两两互质。

```cpp
// Input: n,ai[],bi[]
// Method: solve()
// Output: (returned)
namespace excrt {
const int maxn=100010;
int n;
int ai[maxn],bi[maxn]; //x=a%b
int mul(int a,int b,int mod){
    int res=0;
    while(b>0){
        if(b&1) res=(res+a)%mod;
        a=(a+a)%mod;
        b>>=1;
    }
    return res;
}
int exgcd(int a,int b,int &x,int &y){
    if(b==0){x=1;y=0;return a;}
    int gcd=exgcd(b,a%b,x,y);
    int tp=x;
    x=y; y=tp-a/b*y;
    return gcd;
}
int solve(){
    int x,y,k;
    int M=bi[1],ans=ai[1];
    for(int i=2;i<=n;i++){
        int a=M,b=bi[i],c=(ai[i]-ans%b+b)%b;
        int gcd=exgcd(a,b,x,y),bg=b/gcd;
        if(c%gcd!=0) return -1;
        x=mul(x,c/gcd,bg);
        ans+=x*M;
        M*=bg;
        ans=(ans%M+M)%M;
    }
    return (ans%M+M)%M;
}
}

signed main(){
    int n;
    cin>>n;
    excrt::n=n;
    for(int i=1;i<=n;++i) cin>>excrt::bi[i]>>excrt::ai[i]; //x=a%b
    cout<<excrt::solve();
}

```



## 莫比乌斯反演

例1：[HAOI2011] Problem b

``` cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int N = 1000005;
const int MAXN = 1000005;

bool isNotPrime[MAXN + 1];
int mu[MAXN + 1], phi[MAXN + 1], primes[MAXN + 1], cnt;
inline void euler() {
    isNotPrime[0] = isNotPrime[1] = true;
    mu[1] = 1;
    phi[1] = 1;
    for (int i = 2; i <= MAXN; i++) {
        if (!isNotPrime[i]) {
            primes[++cnt] = i;
            mu[i] = -1;
            phi[i] = i - 1;
        }
        for (int j = 1; j <= cnt; j++) {
            int t = i * primes[j];
            if (t > MAXN) break;
            isNotPrime[t] = true;
            if (i % primes[j] == 0) {
                mu[t] = 0;
                phi[t] = phi[i] * primes[j];
                break;
            } else {
                mu[t] = -mu[i];
                phi[t] = phi[i] * (primes[j] - 1);
            }
        }
    }
    for(int i=1;i<=MAXN;i++) mu[i]+=mu[i-1];
}

int solve(int n,int m,int k) {
    n/=k; m/=k;
    if(n==0 || m==0) return 0;
    int ans=0,l=1,r=0;
    if(n>m) swap(n,m);
    while(l<=n) {
        r=min(n/(n/l),m/(m/l));
        ans+=(mu[r]-mu[l-1])*(n/l)*(m/l);
        l=r+1;
    }
    return ans;
}

signed main() {
    euler();
    int t,a,b,c,d,k;
    ios::sync_with_stdio(false);
    cin>>t;
    while(t--) {
        cin>>a>>b>>c>>d>>k; --a; --c;
        cout<<solve(b,d,k)-solve(a,d,k)-solve(b,c,k)+solve(a,c,k)<<endl;
    }
}
```

例2 

给定 $N, M$，求 $1 \leq x \leq N$，$1 \leq y \leq M$ 且 $\gcd(x, y)$ 为质数的 $(x, y)$ 有多少对。$T = 10^4$，$N, M \leq 10^7$。

首先按套路推导出
$$
ans=\sum_d \lfloor \frac N d \rfloor \lfloor \frac M d \rfloor \sum_{p|d} \mu(\frac d p)
$$
设 
$$
a(d)=\sum_{p|d} \mu(\frac d p)
$$
于是
$$
ans=\sum_d \lfloor \frac N d \rfloor \lfloor \frac M d \rfloor a(d)
$$
便可以整除分块计算。关键在于如何预处理出 $a(d)$。

在预处理完 $\mu$ 后，对于每一个 $p$，枚举 $j=1,2,3,\dots$，将 $\mu(j)$ 加到 $a(pj)$ 上即可，这部分的时间复杂度根据调和级数，为 $O(n \log n)$。由于对于各组数据，$a(d)$ 的预处理是公共的，只需要在所有询问之前做一次即可。

### 各种例子

模板题……
$$\sum\limits_{i=1}^a\sum\limits_{j=1}^b[(i,j)=k] = \sum\limits_{i=1}^a\sum\limits_{j=1}^b[k|i][k|j][({i\over k},{j\over k})=1]=\sum\limits_{i=1}^{a\over k}\sum\limits_{j=1}^{b\over k}[(i,j)=1]$$
继续化简
$$\sum\limits_{i=1}^{b\over k}\sum\limits_{j=1}^{d\over k}\sum\limits_{t|(i,j)}\mu(t)=\sum\limits_{i=1}^{b\over k}[t|i]\sum\limits_{j=1}^{d\over k}[t|j]\mu(t)=\sum\limits_{t=1}^{max({b\over k},{d\over k})}{\lfloor{{b\over k}\over t}\rfloor}{\lfloor{{d\over k}\over t}\rfloor}\mu(t)$$
然后上反演整除分块即可

---

考虑到$lcm(i,j)=\frac{ij}{gcd(i,j)}$

$\sum_{i=1}^n\sum_{j=1}^m\frac{ij}{gcd(i,j)}$

$\sum_{d=1}^{n}\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)==d]\frac{ij}{d}$

$\sum_{d=1}^{n}\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}[gcd(i,j)==1]{ijd}$

$=\sum_{d=1}^{n}d\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}[gcd(i,j)==1]{ij}$

看后面
$\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}[gcd(i,j)==1]{ij}$
$=\sum_{i=1}^{x}\sum_{j=1}^{y}[gcd(i,j)==1]{ij}$

考虑反演
$f(d)=\sum_{i=1}^{x}\sum_{j=1}^{y}[gcd(i,j)==d]{ij}$

$G(d)=\sum_{i=1}^{x}\sum_{j=1}^{y}[d|gcd(i,j)]{ij}$

$G(d)=d^2\sum_{i=1}^{x/d}\sum_{j=1}^{y/d}[1|gcd(i,j)]{ij}$
$G(d)=d^2\sum_{i=1}^{x/d}\sum_{j=1}^{y/d}{ij}$

于是
$f(1)=\sum_{i=1}^x\mu(i)G(i)$

$ans=\sum_{d=1}^{n}d\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}[gcd(i,j)==1]{ij}$

在这里做第一次分块，而后
$f(1)=\sum_{i=1}^x\mu(i)G(i)$

$=\sum_{i=1}^x\mu(i)i^2\sum_{i=1}^{x/d}\sum_{j=1}^{y/d}{ij}$

然后内外各做一次整除分块即可

---

复习一下莫比乌斯反演

首先很显然用一下容斥把它转化成求 $ans=\sum_{i=1}^a \sum_{j=1}^b [{gcd(i,j)=d}]$

我们可以定义 f(d) 和 F(d) 如下：

$f(d)=\sum_{i=1}^N\sum_{j=1}^M[gcd(i,j)=d]$

$F(d)=\sum_{i=1}^N\sum_{j=1}^M[d|gcd(i,j)]$

发现

$\sum_{n|d}f(d)=F(n)=\lfloor\frac Nn\rfloor\lfloor\frac Mn\rfloor$

莫比乌斯反演，得到：

$f(n)=\sum_{n|d}\mu(\lfloor\frac dn\rfloor)F(d)$

于是
$ans=f(d)=\sum_{d|p}\mu(\lfloor\frac pd\rfloor)F(p)$

换个元
$ans=\sum_{p'}\mu(p')F( p' d ) =\sum_{p'=1}^{min(\lfloor\frac Nd\rfloor,\lfloor\frac Md\rfloor)}\mu(p')\lfloor\frac N{p'd}\rfloor \lfloor \frac M{p'd}\rfloor$

把 $p'$ 写作 $p$ ，得到

$ans=\sum_{p}\mu(p)F( p d ) =\sum_{p=1}^{min(\lfloor\frac Nd\rfloor,\lfloor\frac Md\rfloor)}\mu(p)\lfloor\frac N{pd}\rfloor \lfloor \frac M{pd}\rfloor$

---

$$
\begin{aligned} A&=\sum_{i=1}^{n}\sum_{j=1}^n{ijgcd(i,j)} \\ &=\sum_{d=1}^n\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}ijd^3[gcd(i,j)=1]\\
&=\sum_{d=1}^nd^3\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}ij[gcd(i,j)=1]
\end{aligned}
$$

设$f(n)=\sum_{i=1}^{n}\sum_{j=1}^nij[gcd(i,j)=1]$，$s(n)=\sum_{i=1}^{n}\sum_{j=1}^nij$

则
$$\begin{aligned}A&=\sum_{d=1}^nd^3f(\lfloor\frac{n}{d}\rfloor)\end{aligned}$$

而 

$$\sum_{i=1}^{n}i^3=(\sum_{i=1}^ni)^2=[\frac{n(n+1)}{2}]^2$$

有

$$\begin{aligned}s(n)&=\sum_{i=1}^{n}\sum_{j=1}^nij=[\frac{n(n+1)}{2}]^2\\ &=\sum_{i=1}^{n}\sum_{j=1}^nij \\ &=\sum_{t=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{t}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{t}\rfloor}t^2ij[gcd(i,j)=1]
\\
&=\sum_{t=1}^{n}t^2f(\lfloor\frac{n}{t}\rfloor)=f(n)+\sum_{t>1}t^2f(\lfloor\frac{n}{t}\rfloor)
\end{aligned}$$

$$f(n)=s(n)-\sum_{t>1}t^2f(\lfloor\frac{n}{t}\rfloor)=[\frac{n(n+1)}{2}]^2-\sum_{t>1}t^2f(\lfloor\frac{n}{t}\rfloor)$$

数论分块即可
$$\sum_{i=1}^{n}i^2=\frac{n(n+1)(2n+1)}{6}$$

预处理 $f(n)$
$$f(n)=\sum_{i=1}^{n}\sum_{j=1}^nij[gcd(i,j)=1]=f(n-1)+2\sum_{i=1}^{n}in[gcd(i,n)=1]$$

而
$$\sum_{i=1}^ni[gcd(i,n)=1]=n\frac{\varphi(n)}{2}$$

故
$$f(n)=f(n-1)+n^2\varphi(n)$$

---

杜教筛求 $\phi(n)$，
$$
S(n)=n(n+1)/2-\sum_{d=2}^n S(\frac{n}{d})
$$
答案为
$$
\sum_{d=1}^n \phi(d) h(\frac{n}{d})
$$
其中 $h(n)=\sum_{i=1}^n i^2$

顺便学习了一波 `unordered_map`

---

给定 $N, M$，求 $1 \leq x \leq N$，$1 \leq y \leq M$ 且 $\gcd(x, y)$ 为质数的 $(x, y)$ 有多少对。$T = 10^4$，$N, M \leq 10^7$。

首先按套路推导出
$$
ans=\sum_d \lfloor \frac N d \rfloor \lfloor \frac M d \rfloor \sum_{p|d} \mu(\frac d p)
$$
设 
$$
a(d)=\sum_{p|d} \mu(\frac d p)
$$
于是
$$
ans=\sum_d \lfloor \frac N d \rfloor \lfloor \frac M d \rfloor a(d)
$$
便可以整除分块计算。关键在于如何预处理出 $a(d)$。

在预处理完 $\mu$ 后，对于每一个 $p$，枚举 $j=1,2,3,\dots$，将 $\mu(j)$ 加到 $a(pj)$ 上即可，这部分的时间复杂度根据调和级数，为 $O(n \log n)$。由于对于各组数据，$a(d)$ 的预处理是公共的，只需要在所有询问之前做一次即可。

---

先按套路进行一些推导

![1592313291721](C:\Users\10849\AppData\Roaming\Typora\typora-user-images\1592313291721.png)

我们用 BIT 来维护 $h(x)$，将所有询问按照 $a$ 升序排序，当 $a$ 的容许范围扩大时，就将对应的所有 $x$ 满足 $f(x)=a$ 对 $h$ 的贡献进行修改，具体地，对于 $x$，它会对 $ix$ 产生 $a \mu(i)$ 的贡献，这部分单点修改即可。在进行整除分块计算的过程中，在 BIT 上区间求和即可。

---

设 $d(x)$ 为 $x$ 的约数个数，给定 $n,m$，求 $\sum_{i=1}^n\sum_{j=1}^md(ij)$，$n,m,T \le 5\times 10^4$

重要结论如黑色式子所示，其余部分为套路性的反演推导

![](https://img2020.cnblogs.com/blog/1318245/202006/1318245-20200617232203031-2062788529.png)
![](https://img2020.cnblogs.com/blog/1318245/202006/1318245-20200617232216127-26691847.png)

---

对于$A_1,A_2,\cdots,A_N$，求 $\sum_{i=1}^N\sum_{j=1}^N lcm(A_i,A_j)$

经过一波推导得到
$$
\sum_{i=1}^N\sum_{j=1}^N lcm(A_i,A_j) = \sum_{d=1}^N d (\sum_{i=1}^{N/d} i C_{id})^2 \sum_{k|d}k\mu(k)
$$
暴力计算即可

---

给定 $n$，求 $\sum_{i = 1}^n \sum_{j = i + 1}^n \gcd(i, j)$

经过一波推导得到
$$
\sum_{i = 1}^n \sum_{j = i + 1}^n \gcd(i, j)=\sum_{k=1}^n k \sum_{k|d} \mu(\frac d k) [\frac N d]^2
$$
暴力计算即可



## 指数与原根

### 求原根

#### 求最小原根

复杂度 $O(n^{1/4} \log n)$

``` cpp
// Parameter: N
// Method: init()!!! solve(p)
// Output: min proot (returned)
namespace proot {

const int N = 1000005;

int cnt, tot, p;
int vis[N], pr[N], fac[N];

void GetPrime() {
    cnt = 0;
    memset(vis, 0, sizeof(vis));
    for(int i = 2; i < N; i++) {
        if(!vis[i]) {
            pr[cnt++] = i;
            for(int j = 0; j < cnt && pr[j] * i < N; j++) {
                vis[i * pr[j]] = 1;
                if(i % pr[j] == 0) break;
            }
        }
    }
}

void Factor(int x) {
    tot = 0;
    int t = (int) sqrt(x + 0.5);
    for(int i = 0; pr[i] <= t; i++) {
        if(x % pr[i] == 0) {
            fac[tot++] = pr[i];
            while(x % pr[i] == 0) x /= pr[i];
        }
    }
    if(x > 1) fac[tot++] = x;
}

int quick_pow(int n, int m, int mod) {
    int res = 1, tmp = n % mod;
    while(m) {
        if(m & 1) res = res * tmp % mod;
        tmp = tmp * tmp % mod;
        m >>= 1;
    }
    return res;
}

void init() {
    GetPrime();
}

int solve(int _p) {
    p=_p;
    Factor(p - 1);
    for(int g = 2; g < p; g++) {
        bool flag = true;
        for(int i = 0; i < tot; i++) {
            int t = (p - 1) / fac[i];
            if(quick_pow((int)g, (int)t, (int)p) == 1) {
                flag = false;
                break;
            }
        }
        if(flag) {
            return g;
            break;
        }
    }
}
}

```



#### 求全部原根

复杂度 $O(n \log n)$ 

``` cpp
// Parameter: N
// Method: init()!!! solve(x)
// Output: sorted list of proot (returned)
namespace proot {
const int N=1e6+5;
int pr[N+5];
bool check[N+5];
int phi[N+5];
int num;

void init() {
    memset(check, false, sizeof(check));
    phi[1]=1;
    for(int i=2; i<=N; i++) {
        if(!check[i]) {
            pr[num++]=i;
            phi[i]=i-1;
        }
        for(int j=0; j<num; j++) {
            if(i*pr[j]>N) break;
            check[i*pr[j]]=true;
            if(i%pr[j]==0) {
                phi[i*pr[j]]=phi[i]*pr[j];
                break;
            } else {
                phi[i*pr[j]]=phi[i]*(pr[j]-1);
            }
        }
    }
}

void get(int n,vector<int>& fac) {
    fac.clear();
    for(int i=2; i*i<=n; i++)
        if(n%i==0) {
            fac.push_back(i);
            while(n%i==0) n/=i;
        }
    if(n>1) fac.push_back(n);
}

int qpow(int x,int n,int mod) {
    int ret=1;
    for(; n; n>>=1) {
        if(n&1) ret=ret*x%mod;
        x=x*x%mod;
    }
    return ret;
}

vector<int> fac,ans;

bool ok(int x) {
    if(x%2==0) x/=2;
    if(x%2==0) return false;
    for(int i=0; pr[i]*pr[i]<=x; i++) if(x%pr[i]==0) {
            while(x%pr[i]==0) x/=pr[i];
            return x==1;
        }
    return true;
}

int get_g(int p) {
    for(int i=2; i<p; i++) {
        bool flag=false;
        for(int x:fac)
            if(qpow(i,phi[p]/x,p)==1) {
                flag=true;
                break;
            }
        if(!flag&&qpow(i,phi[p],p)==1)  return i;
    }
}

void GetAns(int g,int p,vector<int>& ans) {
    ans.clear();
    ans.push_back(g);
    for(int i=2; i<phi[p]; i++)
        if(__gcd(i,phi[p])==1) ans.push_back(qpow(g,i,p));
}

vector<int> solve(int p) {
    init();
    if(p==2||p==4) return vector<int>{p-1};
    if(!ok(p)) return vector<int>{};
    get(phi[p],fac);
    int g=get_g(p);
    GetAns(g,p,ans);
    sort(ans.begin(),ans.end());
    return ans;
}
}

signed main() {
    int T,x,d;
    ios::sync_with_stdio(false);
    proot::init();
    cin>>T;
    while(T--) {
        cin>>x>>d;
        vector <int> ans=proot::solve(x);
        cout<<ans.size()<<endl;
        for(int i=d;i<=ans.size();i+=d) cout<<ans[i-1]<<" ";
        cout<<endl;
    }
}

/*
4
25 2 36 1 9 6 18 1
[Output]
8
3 12 17 23
0

2

2
5 11
*/

```



**定理**  $n$ 的原根个数是 $\varphi(\varphi(n))$ 



## BSGS

### 基本 BSGS

``` cpp
// b^x = n % p  (b,p)=1
#include <cstdio>
#include <cmath>
#include <map>
using namespace std;
typedef long long ll;
map<ll , ll> f;
map<ll , ll>::iterator it;
ll pow(ll x , ll y , ll mod)
{
    ll ans = 1;
    while(y)
    {
        if(y & 1) ans = ans * x % mod;
        x = x * x % mod , y >>= 1;
    }
    return ans;
}
int main()
{
    ll p , b , n;
    while(scanf("%lld%lld%lld" , &p , &b , &n) != EOF)
    {
        ll m = (ll)ceil(sqrt(p)) , i , t , temp , flag = 0;
        f.clear();
        for(t = 1 , i = 0 ; i < m ; t = t * b % p , i ++ )
            if(f.find(t) == f.end())
                f[t] = i;
        for(t = 1 , temp = pow(b , p - m - 1 , p) , i = 0 ; i < m ; t = t * temp % p , i ++ )
        {
            it = f.find(n * t % p);
            if(it != f.end())
            {
                printf("%lld\n" , i * m + it->second) , flag = 1;
                break;
            }
        }
        if(!flag) printf("no solution\n");
    }
    return 0;
}

```



### 扩展 BSGS

``` cpp
// a^x = b mod p
#include <bits/stdc++.h>
using namespace std;

long long a,b,p,x;
map<long long,long long> mp;
inline long long gcd(long long x,long long y)
{
    return y?gcd(y,x%y):x;
}
inline long long ksm(long long x,long long y,long long mod)
{
    long long res=1;
    while(y)
    {
        if(y&1)
        res=(res*x)%mod;
        x=(x*x)%mod;
        y>>=1;
    }
    return res;
}
inline void exBSGS(long long a,long long b,long long p)
{
    if(b==1)
    {
        printf("0\n");
        return;
    }
    long long d=gcd(a,p),t=1,k=0;
    while(d!=1)
    {
        if(b%d)
        {
            printf("No Solution\n");
            return;
        }
        ++k;
        b/=d;
        p/=d;
        t=(t*(a/d))%p;//[1,k]的处理
        d=gcd(a,p);
        if(b==t)
        {
            printf("%lld\n",k);
            return;
        }
    }
    mp.clear();
    long long m=ceil(sqrt(p)),ans;
    for(int j=0;j<=m;++j)
    {
        if(j==0)
        {
            ans=b%p;
            mp[ans]=j;
            continue;
        }
        ans=(ans*a)%p;
        mp[ans]=j;
    }
    long long x=ksm(a,m,p),pd=0;
    ans=t;
    for(int i=1;i<=m;++i)
    {
        ans=(ans*x)%p;
        if(mp[ans])
        {
            x=i*m-mp[ans];
            printf("%lld\n",x+k);
            pd=1;
            break;
        }
    }
    if(!pd)
    printf("No Solution\n");
    return;
}
int main()
{
    while(~scanf("%lld%lld%lld",&a,&p,&b))
    {
        if(a==0&&b==0&&p==0)
        break;
        a=a%p;
        b=b%p;
        exBSGS(a,b,p);
    }
    return 0;
}
```



### 递推 BSGS

``` cpp
// x[i+1]=(ax[i]+b) % p  Given p,a,b,x1,t
// Find smallest n s.t. x[n]=t
#include <map>
#include <cmath>
#include <cstdio>
using namespace std;
typedef long long ll;
map<ll , ll> mp;
map<ll , ll>::iterator it;
ll u[50010] , v[50010];
int main()
{
    int T;
    scanf("%d" , &T);
    while(T -- )
    {
        ll p , a , b , x , t , m , i , ans = 1ll << 62;
        scanf("%lld%lld%lld%lld%lld" , &p , &a , &b , &x , &t);
        if(!a)
        {
            if(t == x) puts("1");
            else if(t == b) puts("2");
            else puts("-1");
        }
        else
        {
            mp.clear() , m = ceil(sqrt(p));
            u[0] = 1 , v[0] = 0;
            for(i = 1 ; i <= m ; i ++ ) u[i] = u[i - 1] * a % p , v[i] = (a * v[i - 1] + b) % p;
            for(i = 1 ; i <= m ; i ++ )
            {
                x = (x * u[m] + v[m]) % p;
                if((it = mp.find(x)) == mp.end())
                    mp[x] = i;
            }
            for(i = 1 ; i <= m ; i ++ )
                if((it = mp.find((t * u[i] + v[i]) % p)) != mp.end())
                    ans = min(ans , it->second * m - i + 1);
            if(ans == 1ll << 62) puts("-1");
            else printf("%lld\n" , ans);
        }
    }
    return 0;
}

```





# 高等代数

## 矩阵快速幂

``` cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int mod = 7;

struct matrix {
    int a[5][5]={};
    int n,m;
};

matrix I(int n) {
    matrix ret;
    ret.n=n;
    ret.m=n;
    for(int i=1;i<=n;i++) ret.a[i][i]=1;
    return ret;
}

matrix operator * (matrix a, matrix b) {
    matrix ret;
    ret.n = a.n;
    ret.m = b.m;
    for(int i=1;i<=ret.n;i++) {
        for(int j=1;j<=ret.m;j++) {
            for(int k=1;k<=a.m;k++) {
                ret.a[i][j] += a.a[i][k] * b.a[k][j];
                ret.a[i][j] %= mod;
                ret.a[i][j] += mod;
                ret.a[i][j] %= mod;
            }
        }
    }
    return ret;
}

matrix qpow(matrix p, int q) {
    return ((q&1)?p:I(2)) * (q?qpow(p*p,q/2):I(2));
}

signed main() {
    matrix T;
    T.n=2; T.m=2;
    int a,b,n;
    cin>>a>>b>>n;
    T.a[1][1]=a; T.a[1][2]=b;
    T.a[2][1]=1;
    T=qpow(T,n-2);
    matrix A;
    A.n=2; A.m=1;
    A.a[1][1]=1; A.a[2][1]=1;
    if(n==1) cout<<1<<endl;
    else cout<<(T*A).a[1][1];
}

```



## 矩阵计算（同余下的逆元与行列式）

```cpp
// Parameter: N,mod,n
// Input: f[1..n][1..n]
// Method: solve()
// Output: Det: returned; Inv: f[1..n][n+1..2n]
namespace mat {
const int N = 405;
const int mod = 998244353;
int f[N][N<<1],a[N][N],n;
inline void exgcd(int a,int b,int &x,int &y) {
    if(!b) {
        x=1,y=0;
        return;
    }
    exgcd(b,a%b,x,y);
    int t=x;
    x=y,y=t-(a/b)*y;
}

inline int inv(int a,int b) {
    int x,y;
    return exgcd(a,b,x,y),(x%b+b)%b;
}
int getdet() {
    int det=1;
    int flag=0;
    for(int i=1; i<=n; i++) {
        for(int j=i+1; j<=n; j++) {
            int x=i,y=j;
            while(a[y][i]!=0) {
                int t=a[x][i]*inv(a[y][i],mod)%mod;
                for(int k=i; k<=n; k++) (a[x][k]-=t*a[y][k]%mod)%=mod;
                swap(x,y);
            }
            if(x!=i) {
                for(int k=1; k<=n; k++) {
                    swap(a[x][k],a[i][k]);
                }
                flag^=1;
            }
        }
        if(a[i][i]==0)  return 0;
        det=det*a[i][i]%mod;
    }
    if(flag) det=-det;
    det%=mod; det+=mod; det%=mod;
    return det;
}

int solve() {
    int m=n*2;
    for(int i=1;i<=n;i++) {
        for(int j=1;j<=n;j++) a[i][j]=f[i][j], f[i][j+n]=0;
    }
    int ret= getdet();
    for(int i=1; i<=n; ++i) {
        f[i][n+i]=1;
    }
    for(int i=1; i<=n; ++i) {
        for(int j=i; j<=n; j++)
            if(f[j][i]) {
                for(int k=1; k<=m; k++)
                    swap(f[i][k],f[j][k]);
                break;
            }
        if(!f[i][i]) {
            return 0;
        }
        int r=inv(f[i][i],mod);
        for(int j=i; j<=m; ++j)
            f[i][j]=f[i][j]*r%mod;
        for(int j=1; j<=n; ++j)
            if(j!=i) {
                r=f[j][i];
                for(int k=i; k<=m; ++k)
                    f[j][k]=(f[j][k]-r*f[i][k]%mod+mod)%mod;
            }
    }
    return ret;
}
}
```

### 动态维护

``` cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int mod = 998244353;
const int N = 505;

int qpow(int p,int q) {return ((q&1)?p:1) * (q?qpow(p*p%mod,q>>1):1) % mod;}

int n, Q;

// Input: a[][],n
// Method: build() modify(i,j,x)
// Output: inv[][], ans
struct matrix {
    int a[N][N], st[N][N], inv[N][N], ans, n;
    void build() {
        ans=1;
        for(int i=1;i<=n;i++) {
            for(int j=1;j<=n;j++) {
                st[i][j]=a[i][j];
            }
        }
        for (int i = 1; i <= n; i++) inv[i][i] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j++) {
                if (a[j][i]) {
                    for (int k = 1; k <= n; k++) {
                        swap(a[i][k], a[j][k]);
                        swap(inv[i][k], inv[j][k]);
                    }
                    if (j > i) ans = (mod - ans) % mod;
                    break;
                }
            }
            int K = qpow(a[i][i], mod-2);
            for (int j = i+1; j <= n; j++) {
                int tmp = K * a[j][i] % mod;
                for (int k = 1; k <= n; k++) {
                    a[j][k] = (a[j][k] + mod - tmp * a[i][k] % mod) % mod;
                    inv[j][k] = (inv[j][k] + mod - tmp * inv[i][k] % mod) % mod;
                }
            }
        }
        for (int i = n; i >= 1; i--) {
            int K = qpow(a[i][i], mod-2);
            ans = ans * a[i][i] % mod;
            for (int j = 1; j <= n; j++) {
                a[i][j] = a[i][j] * K % mod;
                inv[i][j] = inv[i][j] * K % mod;
            }
            for (int j = 1; j < i; j++) {
                int tmp = a[j][i];
                for (int k = 1; k <= n; k++) {
                    a[j][k] = (a[j][k] + mod - tmp * a[i][k] % mod) % mod;
                    inv[j][k] = (inv[j][k] + mod - tmp * inv[i][k] % mod) % mod;
                }
            }
        }
    }
    void modify(int x,int y,int z) {
        int t = (z + mod - st[x][y]) % mod;
        st[x][y] = z;
        for (int i = 1; i <= n; i++) {
            a[i][y] = (a[i][y] + t * inv[i][x] % mod) % mod;
        }
        {
            int i = y;
            int K = qpow(a[i][i], mod-2);
            ans = ans * a[i][i] % mod;
            for (int j = 1; j <= n; j++) {
                a[i][j] = a[i][j] * K % mod;
                inv[i][j] = inv[i][j] * K % mod;
            }
            for (int j = 1; j <= n; j++) {
                if (j == i) continue;
                int tmp = a[j][i];
                for (int k = 1; k <= n; k++) {
                    a[j][k] = (a[j][k] + mod - tmp * a[i][k] % mod) % mod;
                    inv[j][k] = (inv[j][k] + mod - tmp * inv[i][k] % mod) % mod;
                }
            }
        }
    }
} mat;

signed main() {
    scanf("%d%d", &n, &Q);
    mat.n = n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            scanf("%d", &mat.a[i][j]);
        }
    }
    mat.build();

    while(Q--) {
        int t1,t2,t3;
        scanf("%d%d%d", &t1, &t2, &t3);
        mat.modify(t1,t2,t3);
        printf("%d\n", mat.ans);
    }
}

/*
2 3
0 1
1 0
1 1 1
2 1 2
2 2 1
[Output]
998244352
998244351
998244352
*/
```



## Gauss-Jordan Elimination

``` cpp
#include <bits/stdc++.h>
#define eps 1e-6
using namespace std;

const int N = 1005;

double a[N][N];
int n,p=1;

void gauss_jordan() {
	for(int i=1;i<=n;i++) {
		int r=i;
		for(int j=i+1;j<=n;j++) if(fabs(a[j][i])>fabs(a[r][i])) r=j;
		if(r-i) {for(int j=1;j<=n+1;j++) swap(a[i][j],a[r][j]);}
		if(fabs(a[i][i])<eps) {p=0; return;}
		for(int j=1;j<=n;j++) if(j-i) {
			double tmp=a[j][i]/a[i][i];
			for(int k=i+1;k<=n+1;k++) a[j][k]-=a[i][k]*tmp;
		}
	}
	for(int i=1;i<=n;i++) a[i][n+1]/=a[i][i];
}

int main() {
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n+1;j++)
			cin>>a[i][j];
	gauss_jordan();
	if(p)
		for(int i=1;i<=n;i++) printf("%.2f\n",a[i][n+1]);
	else cout<<"No Solution"<<endl;
}

// Modu det
// Warning: tot = n - 1
// the template is designed for Matrix Tree
int Gauss()
{
    int ans = 1;
    for(int i = 1; i < tot; i ++) // !!!!
    {
        for(int j = i + 1; j < tot; j ++)
            while(f[j][i])
            {
                int t = f[i][i] / f[j][i];
                for(int k = i; k < tot; k ++)
                    f[i][k] = (f[i][k] - t * f[j][k] + mod) % mod;
                swap(f[i], f[j]);
                ans = - ans;
            }
        ans = (ans * f[i][i]) % mod;
    }
    return (ans + mod) % mod;
}

```





## 线性基（异或）

例：求最大 XOR 和

``` cpp
// Linear Base to Get Max xor sum
// Method: insert(x) solve()
struct linear_base {
    int a[64];
    void insert(int k) {
        for(int j=63; j>=0; --j)
            if((k>>j)&1ll)
                if(a[j]==0) {a[j]=k;break;}
                else k^=a[j];
    }
    int solve() { // 最大异或和
        int ans = 0;
        for(int i=59; i>=0; --i)
            if((ans^a[i]) > ans) ans^=a[i];
        return ans;
    }
} l;
```

`bitset` 版本




## 拉格朗日插值

**注意**  该模板中的 $n$ 是点的个数，即多项式是 $n-1$ 次的！

``` cpp
// Input: n,x[],y[]
// Method: solve(x)
// Output: f(x) (returned)
namespace lag {
const int N=2010;
const int mod=998244353;
int n,k,x[N],y[N],ans,s1,s2;
int qpow(int a,int x) {
    int ret=1,nww=a;
    while(x) {
        if(x&1)ret=ret*nww%mod;
        nww=nww*nww%mod;
        x>>=1;
    }
    return ret;
}
int inv(int x) {
    return qpow(x,mod-2);
}
int solve(int _k) {
    k=_k; ans=0;
    for(int i=1; i<=n; i++) {
        s1=y[i]%mod;
        s2=1;
        for(int j=1; j<=n; j++)if(i!=j)s1=s1*(k-x[j])%mod,s2=s2*((x[i]-x[j]%mod)%mod)%mod;
        ans+=s1*inv(s2)%mod;
        ans=(ans+mod)%mod;
    }
    return ans;
}
}

signed main() {
    ios::sync_with_stdio(false);
    int k;
    cin>>lag::n>>k;
    for(int i=1;i<=lag::n;i++) {
        cin>>lag::x[i]>>lag::y[i];
    }
    cout<<lag::solve(k);
}
/* Input
3 100
1 4
2 9
3 16
Output
10201 */

```



# 多项式与卷积

## FFT

``` cpp
#include<bits/stdc++.h>
#define N 262145
#define pi acos(-1)
using namespace std;

namespace po {
typedef complex<double> E;
int n,m,L;
int R[N];
E a[N],b[N];

void fft(E *a,int f){
	for(int i=0;i<n;i++)if(i<R[i])swap(a[i],a[R[i]]);
	for(int i=1;i<n;i<<=1){
		E wn(cos(pi/i),f*sin(pi/i));
		for(int p=i<<1,j=0;j<n;j+=p){
			E w(1,0);
			for(int k=0;k<i;k++,w*=wn){
				E x=a[j+k],y=w*a[j+k+i];
				a[j+k]=x+y;a[j+k+i]=x-y;
			}
		}
	}
}

void mul(int _n,int *aa,int *bb,int *cc){
    n=_n;
    memset(a,0,sizeof a);
    memset(b,0,sizeof b);
    memset(R,0,sizeof R);
    L=0;
    m=n;
	for(int i=0,x;i<=n;i++)a[i]=aa[i];
	for(int i=0,x;i<=m;i++)b[i]=bb[i];
	m*=2;
	for(n=1;n<=m;n<<=1)L++;
	for(int i=0;i<n;i++)R[i]=(R[i>>1]>>1)|((i&1)<<(L-1));
	fft(a,1);fft(b,1);
	for(int i=0;i<=n;i++)a[i]=a[i]*b[i];
	fft(a,-1);
	memset(cc,0,sizeof cc);
	for(int i=0;i<=m;i++) cc[i]=(int)(a[i].real()/n+0.5);
}
}

using po::mul;
```



## 多项式全家桶（模）

注意

- 调用 `presolve` 时请务必指定两倍大小！常量 $N$ 请设置为大于对应的 $2$ 的整数次幂
- `sqrt` 不限制 `a[0]`
- `loge`,`expr` 限制 $a[0]$，做多项式幂函数时请特判掉前缀 $0$，然后除以最低次幂项系数，最后将系数的若干次幂乘回去

``` cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int N = 262150;
const int mod = 998244353;

int qpow(int p,int q) {return (q&1?p:1)*(q?qpow(p*p%mod,q/2):1)%mod;}

namespace cipolla {
inline int le(int x) {return qpow(x,(mod-1)/2);}
int w;
struct comp {
    int x,y;
    comp(int a=0,int b=0) {x=a;y=b;}
};
comp operator + (comp a,comp b) {return comp((a.x+b.x)%mod,(a.y+b.y)%mod);}
comp operator - (comp a,comp b) {return comp((a.x-b.x+mod)%mod,(a.y-b.y+mod)%mod);}
comp operator * (comp a,comp b) {return comp((a.x*b.x+a.y*b.y%mod*w)%mod,(a.x*b.y+a.y*b.x)%mod);}
comp operator ^ (comp a,int b) {comp o(1,0); for(;b;a=a*a,b>>=1) if(b&1) o=o*a; return o;}
int calc(int x) {
    x%=mod;
    int a;
    while(true) {
        a=rand();
        w=(a*a-x+mod)%mod;
        if(le(w)==mod-1) break;
    }
    comp s=comp(a,1)^((mod+1)/2);
    return min(s.x,mod-s.x);
}
}

namespace po {
int rev[N],inv[N],w[N],sz;
void presolve(int l) {
    int len=1;
    sz=0;
    while(len<l) len<<=1, ++sz;
    for(int i=1;i<len;i++) {
        inv[i]=(i==1?1:inv[mod%i]*(mod-mod/i)%mod);
        rev[i]=(rev[i>>1]>>1)|((i&1)<<(sz-1));
    }
    int wn=qpow(3,(mod-1)/len);
    w[len/2]=1;
    for(int i=len/2+1;i<len;i++) w[i]=w[i-1]*wn%mod;
    for(int i=len/2-1;i;i--) w[i]=w[i<<1];
}
int pre(int l) {int g; for(g=1;g<l;g<<=1); return g;}
void ntt(int *a,int o,int n) {
    static unsigned long long s[N];
    int t=sz-__builtin_ctz(n),x;
    for(int i=0;i<n;i++) s[rev[i]>>t]=a[i];
    for(int l=1;l<n;l<<=1) for(int i=0;i<n;i+=l<<1) for(int j=0;j<l;j++) {
        x=s[i+j+l]*w[j+l]%mod;
        s[i+j+l]=s[i+j]+mod-x;
        s[i+j]+=x;
    }
    for(int i=0;i<n;i++) a[i]=s[i]%mod;
    if(o) {
        x=qpow(n,mod-2);
        for(int i=0;i<n;i++) a[i]=a[i]*x%mod;
        reverse(a+1,a+n);
    }
}
void mult(int n,int *x,int *y,int *z) {
    static int a[N],b[N];
    int l=pre(n<<1);
    for(int i=0;i<l;i++) {
        a[i]=(i<n?x[i]:0);
        b[i]=(i<n?y[i]:0);
    }
    ntt(a,0,l); ntt(b,0,l);
    for(int i=0;i<l;i++) z[i]=a[i]*b[i]%mod;
    ntt(z,1,l);
    for(int i=n;i<l;i++) z[i]=0;
}
void inve(int len,int *a,int *b) {
    if(len==1) *b=qpow(*a,mod-2);
    else {
        inve((len+1)/2,a,b);
        static int c[N];
        int n=pre(len<<1);
        for(int i=0;i<n;i++) i<len?c[i]=a[i]:b[i]=c[i]=0;
        ntt(b,0,n);
        ntt(c,0,n);
        for(int i=0;i<n;i++) b[i]=((b[i]+b[i]-b[i]*b[i]%mod*c[i])%mod+mod)%mod;
        ntt(b,1,n);
        for(int i=len;i<n;i++) b[i]=0;
    }
}
void sqrt(int n,int *a,int *b) {
    if(n==1) *b=cipolla::calc(*a);
    else {
        sqrt((n+1)/2,a,b);
        static int c[N];
        inve(n,b,c);
        mult(n,a,c,c);
        for(int i=0;i<n;i++) b[i]=(b[i]+c[i])*inv[2]%mod;
    }
}
void deri(int n,int *a,int *b) {
    for(int i=0;i<n-1;i++) b[i]=a[i+1]*(i+1)%mod;
    b[n-1]=0;
}
void inte(int n,int *a,int *b) {
    for(int i=n-1;i>0;--i) b[i]=a[i-1]*inv[i]%mod;
    b[0]=0;
}
void loge(int n,int *a,int *b) {
    static int c[N];
    inve(n,a,b);
    deri(n,a,c);
    mult(n,b,c,b);
    inte(n,b,b);
}
void expr(int n,int *a,int *b) {
    if(n==1) *b=1;
    else {
        expr((n+1)/2,a,b);
        static int c[N];
        loge(n,b,c);
        for(int i=0;i<n;i++) c[i]=(a[i]-c[i]+mod)%mod;
        c[0]=(c[0]+1)%mod;
        mult(n,b,c,b);
    }
}
}

int n,k,a[N],b[N],c[N];

signed main() {
    ios::sync_with_stdio(false);
    cin>>n>>k;
    po::presolve((n+1)<<1);
    for(int i=0;i<=n;i++) cin>>a[i];
    po::sqrt(n+1,a,b);
    po::inve(n+1,b,c);
    po::inte(n+1,c,b);
    po::expr(n+1,b,c);
    a[0]=2;
    for(int i=0;i<=n;i++) a[i]=(mod+a[i]-c[i])%mod;
    po::loge(n+1,a,b);
    b[0]++;
    po::loge(n+1,b,c);
    for(int i=0;i<=n;i++) c[i]=c[i]*k%mod;
    po::expr(n+1,c,b);
    po::deri(n+1,b,a);
    for(int i=0;i<n;i++) cout<<a[i]<<" ";
}


```

``` 
7 19260817
1 9 2 6 0 8 1 7

154086536 791514529 907426922 796196275 141417382 116874127 473725705
```



## 快速莫比乌斯变换

``` cpp
#include <bits/stdc++.h>
using namespace std;

double a[2000005],ans;
int n;

signed main() {
    ios::sync_with_stdio(false);
    cin>>n;
    for(int i=0;i<1<<n;i++) cin>>a[i];
    int up=1<<n;
    for(int k=1;k<up;k<<=1)
        for(int s=0;s<up;s+=k<<1)
            for(int i=s;i<s+k;i++)
            {double a0=a[i];double a1=a[i+k];a[i]=a0;a[i+k]=a0+a1;}
    for(int i=1;i<up;i++) {
        if(1-a[(up-1)^i]<1e-10) {
            puts("INF");
            return 0;
        }
        ans += (__builtin_popcount(i)%2?1:-1)*1/(1-a[(up-1)^i]);
    }
    printf("%.8lf",ans);
}
```

例题：[HAOI2015] 按位或

初态下，分数为 $0$。每秒钟，随机选择一个 $[0,2^n-1]$ 的数字与当前的数字做按位或运算。选择数字 $i$ 的概率是 $p_i$，求分数达到 $2^n-1$ 的期望时间。$n\leq 20$

先介绍一下 Min-Max 容斥原理。设 $\max(S),\min(S)$ 分别是集合 $S$ 中的最大值与最小值，则有
$$
\max(S)=\sum_{T\subseteq S} (-1)^{|T|+1} \min(T)
\\
\min(S)=\sum_{T\subseteq S} (-1)^{|T|+1} \max(T)
$$
Min-Max 容斥原理对随机变量的期望成立。

回到原问题，对于某个位置集合，考虑将每个位变为 $1$ 的时间扔进一个集合，那么 $\min(S)$ 是集合中第一个变 $1$ 元素的时间，$\max(S)$ 是最后一个。

于是答案就是 $E(\max(U))$，其中 $U$ 为全集。利用 Min-Max 容斥原理我们可以将它转化为求对于每一个子集的 $E(\min(S))$，而 $\min(S)$ 符合几何分布，于是有
$$
\begin{aligned}
E(\min(S)) &= \sum_{i=1}^{\infty} iP(\min(S)=i)
\\
&= \sum_{i=1}^\infty i(\sum_{TS=\varnothing}p_T)^{i-1}(1-\sum_{TS=\varnothing}p_T)
\\
&= \frac{1}{1-\sum_{TS=\varnothing}p_T}
\end{aligned}
$$
于是现在我们需要对所有 $S\subseteq U$，求出 $\sum_{TS=\varnothing} p_T$

考虑 FMT，可以用来求出 $\forall S,\ g(S)=\sum_{T\subseteq S} f(T)$

```cpp
#include <bits/stdc++.h>
using namespace std;

double a[2000005],ans;
int n;

signed main() {
    ios::sync_with_stdio(false);
    cin>>n;
    for(int i=0;i<1<<n;i++) cin>>a[i];
    int up=1<<n;
    for(int k=1;k<up;k<<=1)
        for(int s=0;s<up;s+=k<<1)
            for(int i=s;i<s+k;i++)
            {double a0=a[i];double a1=a[i+k];a[i]=a0;a[i+k]=a0+a1;}
    for(int i=1;i<up;i++) {
        if(1-a[(up-1)^i]<1e-10) {
            puts("INF");
            return 0;
        }
        ans += (__builtin_popcount(i)%2?1:-1)*1/(1-a[(up-1)^i]);
    }
    printf("%.8lf",ans);
}

```



## 快速沃尔什变换
$$
C_k=\sum_{i|j=k}A_i*B_j
,\ \ \  \
C_k=\sum_{i\&j=k}A_i*B_j
,\ \ \ \
C_k=\sum_{i\wedge j=k}A_i*B_j
$$
``` cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int N = 1 << 17 | 1;
const int mod = 998244353;

int qpow(int p,int q)
{
    return (q&1 ? p : 1) * (q ? qpow(p*p%mod,q/2) : 1) % mod;
}

int inv(int p)
{
    return qpow(p, mod-2);
}

int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}

void rd(int &x)
{
    x=read();
}

void md(int &a)
{
    a%=mod;
    a+=mod;
    a%=mod;
}

//////////////////////////
namespace fwt
{
int n, m;
int a[N], b[N];

void load(int m, int *A, int *B)
{
    n = 1 << m;
    for (int i = 0; i < n; i++) a[i] = A[i], b[i] = B[i];
}

void get()
{
    for (int i = 0; i < n; i++) a[i] *= b[i], md(a[i]);
}

void OR(int *f, int x = 1)
{
    for (int o = 2, k = 1; o <= n; o <<= 1, k <<= 1)
        for (int i = 0; i < n; i += o)
            for (int j = 0; j < k; j++)
                f[i+j+k] += f[i+j] * x, md(f[i+j+k]);
}

void AND(int *f, int x = 1)
{
    for (int o = 2, k = 1; o <= n; o <<= 1, k <<= 1)
        for (int i = 0; i < n; i += o)
            for (int j = 0; j < k; j++)
                f[i+j] += f[i+j+k] * x, md(f[i+j]);
}

void XOR(int *f, int x = 1)
{
    for (int o = 2, k = 1; o <= n; o <<= 1, k <<= 1)
        for (int i = 0; i < n; i += o)
            for (int j = 0; j < k; j++)
                f[i+j] += f[i+j+k],
                          f[i+j+k] = f[i+j] - f[i+j+k] - f[i+j+k],
                                     md(f[i+j]), md(f[i+j+k]),
                                     f[i+j] *= x, f[i+j+k] *= x,
                                               md(f[i+j]), md(f[i+j+k]);
}

void solve_and(int m,int *A,int *B,int *c)
{
    load(m,A,B), AND(a), AND(b), get(), AND(a, mod - 1);
    memcpy(c,a,(1<<m)*sizeof(int));
}

void solve_or(int m,int *A,int *B,int *c)
{
    load(m,A,B), OR(a), OR(b), get(), OR(a, mod - 1);
    memcpy(c,a,(1<<m)*sizeof(int));
}

void solve_xor(int m,int *A,int *B,int *c)
{
    load(m,A,B), XOR(a), XOR(b), get(), XOR(a, inv(2));
    memcpy(c,a,(1<<m)*sizeof(int));
}
} // namespace fwt

int A[N], B[N], C[N];

signed main()
{
    int n, m;
    rd(m), n = 1 << m;
    for (int i = 0; i < n; i++) rd(A[i]);
    for (int i = 0; i < n; i++) rd(B[i]);

    fwt::solve_or(m,A,B,C);
    for(int i=0; i<n; i++) cout<<C[i]<<" ";
    cout<<endl;

    fwt::solve_and(m,A,B,C);
    for(int i=0; i<n; i++) cout<<C[i]<<" ";
    cout<<endl;

    fwt::solve_xor(m,A,B,C);
    for(int i=0; i<n; i++) cout<<C[i]<<" ";
    cout<<endl;

    return 0;
}

```



# 位运算

## 手工 popcount

用于需要 `long long` 或者其它玄学情况

``` cpp
namespace popcnter {
    int bt[65536];
    int popcnt (int x) {
        int t=0;
        while(x>=65536){
            t+=bt[x&65535];
            x>>=16;
        }
        return t+bt[x];
    }
    void init() {
        for(int i=0;i<65536;i++) {
            bt[i]=0;
            int x=i;
            while(x) bt[i]+=(x&1),x>>=1;
        }
    }
}
```





# 组合数学

## Polya

一个经典例题

### Description

求 $n$ 元环的 $n$ 染色方案数，旋转同构，翻转不同构，颜色可以不用完。

### Solution

根据 Polya 定理得出计算式，然后就是非常套路的推导了。

![](https://img2020.cnblogs.com/blog/1318245/202006/1318245-20200616122256029-320876592.png)

对于欧拉函数，暴力计算即可

```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long
const int N = 1000005;
const int mod = 1e+9+7;

namespace prime {
    const int MAXN = 1000005;
    bool isNotPrime[MAXN + 1];
    int mu[MAXN + 1], phi[MAXN + 1], primes[MAXN + 1], cnt, a[N];
    inline void euler() {
        isNotPrime[0] = isNotPrime[1] = true;
        mu[1] = 1;
        for (int i = 2; i <= MAXN; i++) {
            if (!isNotPrime[i]) {
                primes[++cnt] = i;
                mu[i] = -1;
            }
            for (int j = 1; j <= cnt; j++) {
                int t = i * primes[j];
                if (t > MAXN) break;
                isNotPrime[t] = true;
                if (i % primes[j] == 0) {
                    mu[t] = 0;
                    break;
                } else {
                    mu[t] = -mu[i];
                }
            }
        }
        for(int i=1;i<=cnt;i++) {
            int p=primes[i];
            for(int j=1;p*j<N;j++) {
                a[p*j]+=mu[j];
            }
        }
        for(int i=1;i<N;i++) {
            a[i]+=a[i-1];
        }
    }
}

int phi(int n) {
    int ans=n,t=n;
    for(int i=2;i*i<=n;i++) {
        if(n%i==0 && !prime::isNotPrime[i]) {
            ans=ans/i*(i-1);
            while(t%i==0) t/=i;
        }
    }
    if(t>1) ans=ans/t*(t-1);
    return ans;
}

int qpow(int p,int q) {return (q&1?p:1)*(q?qpow(p*p%mod,q/2):1)%mod;}
int inv(int p) {return qpow(p,mod-2);}

int solve(int n) {
    int ans=0;
    for(int i=1;i*i<=n;i++) {
        if(n%i==0) {
            ans+=qpow(n,i)*phi(n/i)%mod;
            if(i*i!=n) ans+=qpow(n,n/i)*phi(i)%mod;
            ans%=mod;
        }
    }
    ans*=inv(n);
    ans%=mod;
    return ans;
}

signed main() {
    int t,n;
    ios::sync_with_stdio(false);
    prime::euler();
    cin>>t;
    while(t--) {
        cin>>n;
        cout<<solve(n)<<endl;
    }
}

```





## Min-Max 容斥原理

先介绍一下 Min-Max 容斥原理。设 $\max(S),\min(S)$ 分别是集合 $S$ 中的最大值与最小值，则有
$$
\max(S)=\sum_{T\subseteq S} (-1)^{|T|+1} \min(T)
\\
\min(S)=\sum_{T\subseteq S} (-1)^{|T|+1} \max(T)
$$
Min-Max 容斥原理对随机变量的期望成立。

例题详见【多项式与卷积-快速莫比乌斯变换】一节中的例题。



## 指数与原根

### 求原根

#### 求最小原根

复杂度 $O(n^{1/4} \log n)$

```cpp
// Parameter: N
// Method: init()!!! solve(p)
// Output: min proot (returned)
namespace proot {

const int N = 1000005;

int cnt, tot, p;
int vis[N], pr[N], fac[N];

void GetPrime() {
    cnt = 0;
    memset(vis, 0, sizeof(vis));
    for(int i = 2; i < N; i++) {
        if(!vis[i]) {
            pr[cnt++] = i;
            for(int j = 0; j < cnt && pr[j] * i < N; j++) {
                vis[i * pr[j]] = 1;
                if(i % pr[j] == 0) break;
            }
        }
    }
}

void Factor(int x) {
    tot = 0;
    int t = (int) sqrt(x + 0.5);
    for(int i = 0; pr[i] <= t; i++) {
        if(x % pr[i] == 0) {
            fac[tot++] = pr[i];
            while(x % pr[i] == 0) x /= pr[i];
        }
    }
    if(x > 1) fac[tot++] = x;
}

int quick_pow(int n, int m, int mod) {
    int res = 1, tmp = n % mod;
    while(m) {
        if(m & 1) res = res * tmp % mod;
        tmp = tmp * tmp % mod;
        m >>= 1;
    }
    return res;
}

void init() {
    GetPrime();
}

int solve(int _p) {
    p=_p;
    Factor(p - 1);
    for(int g = 2; g < p; g++) {
        bool flag = true;
        for(int i = 0; i < tot; i++) {
            int t = (p - 1) / fac[i];
            if(quick_pow((int)g, (int)t, (int)p) == 1) {
                flag = false;
                break;
            }
        }
        if(flag) {
            return g;
            break;
        }
    }
}
}

```



#### 求全部原根

复杂度 $O(n \log n)$ 

```cpp
// Parameter: N
// Method: init()!!! solve(x)
// Output: sorted list of proot (returned)
namespace proot {
const int N=1e6+5;
int pr[N+5];
bool check[N+5];
int phi[N+5];
int num;

void init() {
    memset(check, false, sizeof(check));
    phi[1]=1;
    for(int i=2; i<=N; i++) {
        if(!check[i]) {
            pr[num++]=i;
            phi[i]=i-1;
        }
        for(int j=0; j<num; j++) {
            if(i*pr[j]>N) break;
            check[i*pr[j]]=true;
            if(i%pr[j]==0) {
                phi[i*pr[j]]=phi[i]*pr[j];
                break;
            } else {
                phi[i*pr[j]]=phi[i]*(pr[j]-1);
            }
        }
    }
}

void get(int n,vector<int>& fac) {
    fac.clear();
    for(int i=2; i*i<=n; i++)
        if(n%i==0) {
            fac.push_back(i);
            while(n%i==0) n/=i;
        }
    if(n>1) fac.push_back(n);
}

int qpow(int x,int n,int mod) {
    int ret=1;
    for(; n; n>>=1) {
        if(n&1) ret=ret*x%mod;
        x=x*x%mod;
    }
    return ret;
}

vector<int> fac,ans;

bool ok(int x) {
    if(x%2==0) x/=2;
    if(x%2==0) return false;
    for(int i=0; pr[i]*pr[i]<=x; i++) if(x%pr[i]==0) {
            while(x%pr[i]==0) x/=pr[i];
            return x==1;
        }
    return true;
}

int get_g(int p) {
    for(int i=2; i<p; i++) {
        bool flag=false;
        for(int x:fac)
            if(qpow(i,phi[p]/x,p)==1) {
                flag=true;
                break;
            }
        if(!flag&&qpow(i,phi[p],p)==1)  return i;
    }
}

void GetAns(int g,int p,vector<int>& ans) {
    ans.clear();
    ans.push_back(g);
    for(int i=2; i<phi[p]; i++)
        if(__gcd(i,phi[p])==1) ans.push_back(qpow(g,i,p));
}

vector<int> solve(int p) {
    init();
    if(p==2||p==4) return vector<int>{p-1};
    if(!ok(p)) return vector<int>{};
    get(phi[p],fac);
    int g=get_g(p);
    GetAns(g,p,ans);
    sort(ans.begin(),ans.end());
    return ans;
}
}

signed main() {
    int T,x,d;
    ios::sync_with_stdio(false);
    proot::init();
    cin>>T;
    while(T--) {
        cin>>x>>d;
        vector <int> ans=proot::solve(x);
        cout<<ans.size()<<endl;
        for(int i=d;i<=ans.size();i+=d) cout<<ans[i-1]<<" ";
        cout<<endl;
    }
}

/*
4
25 2 36 1 9 6 18 1
[Output]
8
3 12 17 23
0

2

2
5 11
*/

```



**定理**  $n$ 的原根个数是 $\varphi(\varphi(n))$ 



# 高等代数

## 矩阵快速幂

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int mod = 7;

struct matrix {
    int a[5][5]={};
    int n,m;
};

matrix I(int n) {
    matrix ret;
    ret.n=n;
    ret.m=n;
    for(int i=1;i<=n;i++) ret.a[i][i]=1;
    return ret;
}

matrix operator * (matrix a, matrix b) {
    matrix ret;
    ret.n = a.n;
    ret.m = b.m;
    for(int i=1;i<=ret.n;i++) {
        for(int j=1;j<=ret.m;j++) {
            for(int k=1;k<=a.m;k++) {
                ret.a[i][j] += a.a[i][k] * b.a[k][j];
                ret.a[i][j] %= mod;
                ret.a[i][j] += mod;
                ret.a[i][j] %= mod;
            }
        }
    }
    return ret;
}

matrix qpow(matrix p, int q) {
    return ((q&1)?p:I(2)) * (q?qpow(p*p,q/2):I(2));
}

signed main() {
    matrix T;
    T.n=2; T.m=2;
    int a,b,n;
    cin>>a>>b>>n;
    T.a[1][1]=a; T.a[1][2]=b;
    T.a[2][1]=1;
    T=qpow(T,n-2);
    matrix A;
    A.n=2; A.m=1;
    A.a[1][1]=1; A.a[2][1]=1;
    if(n==1) cout<<1<<endl;
    else cout<<(T*A).a[1][1];
}

```



## 矩阵计算（同余下的逆元与行列式）

```cpp
// Parameter: N,mod,n
// Input: f[1..n][1..n]
// Method: solve()
// Output: Det: returned; Inv: f[1..n][n+1..2n]
namespace mat {
const int N = 405;
const int mod = 998244353;
int f[N][N<<1],a[N][N],n;
inline void exgcd(int a,int b,int &x,int &y) {
    if(!b) {
        x=1,y=0;
        return;
    }
    exgcd(b,a%b,x,y);
    int t=x;
    x=y,y=t-(a/b)*y;
}

inline int inv(int a,int b) {
    int x,y;
    return exgcd(a,b,x,y),(x%b+b)%b;
}
int getdet() {
    int det=1;
    int flag=0;
    for(int i=1; i<=n; i++) {
        for(int j=i+1; j<=n; j++) {
            int x=i,y=j;
            while(a[y][i]!=0) {
                int t=a[x][i]*inv(a[y][i],mod)%mod;
                for(int k=i; k<=n; k++) (a[x][k]-=t*a[y][k]%mod)%=mod;
                swap(x,y);
            }
            if(x!=i) {
                for(int k=1; k<=n; k++) {
                    swap(a[x][k],a[i][k]);
                }
                flag^=1;
            }
        }
        if(a[i][i]==0)  return 0;
        det=det*a[i][i]%mod;
    }
    if(flag) det=-det;
    det%=mod; det+=mod; det%=mod;
    return det;
}

int solve() {
    int m=n*2;
    for(int i=1;i<=n;i++) {
        for(int j=1;j<=n;j++) a[i][j]=f[i][j], f[i][j+n]=0;
    }
    int ret= getdet();
    for(int i=1; i<=n; ++i) {
        f[i][n+i]=1;
    }
    for(int i=1; i<=n; ++i) {
        for(int j=i; j<=n; j++)
            if(f[j][i]) {
                for(int k=1; k<=m; k++)
                    swap(f[i][k],f[j][k]);
                break;
            }
        if(!f[i][i]) {
            return 0;
        }
        int r=inv(f[i][i],mod);
        for(int j=i; j<=m; ++j)
            f[i][j]=f[i][j]*r%mod;
        for(int j=1; j<=n; ++j)
            if(j!=i) {
                r=f[j][i];
                for(int k=i; k<=m; ++k)
                    f[j][k]=(f[j][k]-r*f[i][k]%mod+mod)%mod;
            }
    }
    return ret;
}
}
```

### 动态维护

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int mod = 998244353;
const int N = 505;

int qpow(int p,int q) {return ((q&1)?p:1) * (q?qpow(p*p%mod,q>>1):1) % mod;}

int n, Q;

// Input: a[][],n
// Method: build() modify(i,j,x)
// Output: inv[][], ans
struct matrix {
    int a[N][N], st[N][N], inv[N][N], ans, n;
    void build() {
        ans=1;
        for(int i=1;i<=n;i++) {
            for(int j=1;j<=n;j++) {
                st[i][j]=a[i][j];
            }
        }
        for (int i = 1; i <= n; i++) inv[i][i] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j++) {
                if (a[j][i]) {
                    for (int k = 1; k <= n; k++) {
                        swap(a[i][k], a[j][k]);
                        swap(inv[i][k], inv[j][k]);
                    }
                    if (j > i) ans = (mod - ans) % mod;
                    break;
                }
            }
            int K = qpow(a[i][i], mod-2);
            for (int j = i+1; j <= n; j++) {
                int tmp = K * a[j][i] % mod;
                for (int k = 1; k <= n; k++) {
                    a[j][k] = (a[j][k] + mod - tmp * a[i][k] % mod) % mod;
                    inv[j][k] = (inv[j][k] + mod - tmp * inv[i][k] % mod) % mod;
                }
            }
        }
        for (int i = n; i >= 1; i--) {
            int K = qpow(a[i][i], mod-2);
            ans = ans * a[i][i] % mod;
            for (int j = 1; j <= n; j++) {
                a[i][j] = a[i][j] * K % mod;
                inv[i][j] = inv[i][j] * K % mod;
            }
            for (int j = 1; j < i; j++) {
                int tmp = a[j][i];
                for (int k = 1; k <= n; k++) {
                    a[j][k] = (a[j][k] + mod - tmp * a[i][k] % mod) % mod;
                    inv[j][k] = (inv[j][k] + mod - tmp * inv[i][k] % mod) % mod;
                }
            }
        }
    }
    void modify(int x,int y,int z) {
        int t = (z + mod - st[x][y]) % mod;
        st[x][y] = z;
        for (int i = 1; i <= n; i++) {
            a[i][y] = (a[i][y] + t * inv[i][x] % mod) % mod;
        }
        {
            int i = y;
            int K = qpow(a[i][i], mod-2);
            ans = ans * a[i][i] % mod;
            for (int j = 1; j <= n; j++) {
                a[i][j] = a[i][j] * K % mod;
                inv[i][j] = inv[i][j] * K % mod;
            }
            for (int j = 1; j <= n; j++) {
                if (j == i) continue;
                int tmp = a[j][i];
                for (int k = 1; k <= n; k++) {
                    a[j][k] = (a[j][k] + mod - tmp * a[i][k] % mod) % mod;
                    inv[j][k] = (inv[j][k] + mod - tmp * inv[i][k] % mod) % mod;
                }
            }
        }
    }
} mat;

signed main() {
    scanf("%d%d", &n, &Q);
    mat.n = n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            scanf("%d", &mat.a[i][j]);
        }
    }
    mat.build();

    while(Q--) {
        int t1,t2,t3;
        scanf("%d%d%d", &t1, &t2, &t3);
        mat.modify(t1,t2,t3);
        printf("%d\n", mat.ans);
    }
}

/*
2 3
0 1
1 0
1 1 1
2 1 2
2 2 1
[Output]
998244352
998244351
998244352
*/
```



## 线性基（异或）

例：求最大 XOR 和

```cpp
// Linear Base to Get Max xor sum
// Method: insert(x) solve()
struct linear_base {
    int a[64];
    void insert(int k) {
        for(int j=63; j>=0; --j)
            if((k>>j)&1ll)
                if(a[j]==0) {a[j]=k;break;}
                else k^=a[j];
    }
    int solve() {
        int ans = 0;
        for(int i=59; i>=0; --i)
            if((ans^a[i]) > ans) ans^=a[i];
        return ans;
    }
} l;
```

`bitset` 版本

```cpp
struct linear_base {
    bitset <1024> a[1024];
    void insert(bitset<1024> k) {
        for(int j=1023; j>=0; --j)
            if((k>>j)[0])
                if(a[j]==0) {a[j]=k;break;}
                else k^=a[j];
    }
} lb;
```

## 拉格朗日插值

**注意**  该模板中的 $n$ 是点的个数，即多项式是 $n-1$ 次的！

```cpp
// Input: n,x[],y[]
// Method: solve(x)
// Output: f(x) (returned)
namespace lag {
const int N=2010;
const int mod=998244353;
int n,k,x[N],y[N],ans,s1,s2;
int qpow(int a,int x) {
    int ret=1,nww=a;
    while(x) {
        if(x&1)ret=ret*nww%mod;
        nww=nww*nww%mod;
        x>>=1;
    }
    return ret;
}
int inv(int x) {
    return qpow(x,mod-2);
}
int solve(int _k) {
    k=_k; ans=0;
    for(int i=1; i<=n; i++) {
        s1=y[i]%mod;
        s2=1;
        for(int j=1; j<=n; j++)if(i!=j)s1=s1*(k-x[j])%mod,s2=s2*((x[i]-x[j]%mod)%mod)%mod;
        ans+=s1*inv(s2)%mod;
        ans=(ans+mod)%mod;
    }
    return ans;
}
}

signed main() {
    ios::sync_with_stdio(false);
    int k;
    cin>>lag::n>>k;
    for(int i=1;i<=lag::n;i++) {
        cin>>lag::x[i]>>lag::y[i];
    }
    cout<<lag::solve(k);
}
/* Input
3 100
1 4
2 9
3 16
Output
10201 */

```



# 多项式与卷积

## FFT

```cpp
#include<bits/stdc++.h>
#define N 262145
#define pi acos(-1)
using namespace std;

namespace po {
typedef complex<double> E;
int n,m,L;
int R[N];
E a[N],b[N];

void fft(E *a,int f){
	for(int i=0;i<n;i++)if(i<R[i])swap(a[i],a[R[i]]);
	for(int i=1;i<n;i<<=1){
		E wn(cos(pi/i),f*sin(pi/i));
		for(int p=i<<1,j=0;j<n;j+=p){
			E w(1,0);
			for(int k=0;k<i;k++,w*=wn){
				E x=a[j+k],y=w*a[j+k+i];
				a[j+k]=x+y;a[j+k+i]=x-y;
			}
		}
	}
}

void mul(int _n,int *aa,int *bb,int *cc){
    n=_n;
    memset(a,0,sizeof a);
    memset(b,0,sizeof b);
    memset(R,0,sizeof R);
    L=0;
    m=n;
	for(int i=0,x;i<=n;i++)a[i]=aa[i];
	for(int i=0,x;i<=m;i++)b[i]=bb[i];
	m*=2;
	for(n=1;n<=m;n<<=1)L++;
	for(int i=0;i<n;i++)R[i]=(R[i>>1]>>1)|((i&1)<<(L-1));
	fft(a,1);fft(b,1);
	for(int i=0;i<=n;i++)a[i]=a[i]*b[i];
	fft(a,-1);
	memset(cc,0,sizeof cc);
	for(int i=0;i<=m;i++) cc[i]=(int)(a[i].real()/n+0.5);
}
}

using po::mul;
```



## 多项式全家桶（模）

注意

- 调用 `presolve` 时请务必指定两倍大小！常量 $N$ 请设置为大于对应的 $2$ 的整数次幂
- `sqrt` 不限制 `a[0]`
- `loge`,`expr` 限制 $a[0]$，做多项式幂函数时请特判掉前缀 $0$，然后除以最低次幂项系数，最后将系数的若干次幂乘回去

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int N = 262150;
const int mod = 998244353;

int qpow(int p,int q) {return (q&1?p:1)*(q?qpow(p*p%mod,q/2):1)%mod;}

namespace cipolla {
inline int le(int x) {return qpow(x,(mod-1)/2);}
int w;
struct comp {
    int x,y;
    comp(int a=0,int b=0) {x=a;y=b;}
};
comp operator + (comp a,comp b) {return comp((a.x+b.x)%mod,(a.y+b.y)%mod);}
comp operator - (comp a,comp b) {return comp((a.x-b.x+mod)%mod,(a.y-b.y+mod)%mod);}
comp operator * (comp a,comp b) {return comp((a.x*b.x+a.y*b.y%mod*w)%mod,(a.x*b.y+a.y*b.x)%mod);}
comp operator ^ (comp a,int b) {comp o(1,0); for(;b;a=a*a,b>>=1) if(b&1) o=o*a; return o;}
int calc(int x) {
    x%=mod;
    int a;
    while(true) {
        a=rand();
        w=(a*a-x+mod)%mod;
        if(le(w)==mod-1) break;
    }
    comp s=comp(a,1)^((mod+1)/2);
    return min(s.x,mod-s.x);
}
}

namespace po {
int rev[N],inv[N],w[N],sz;
void presolve(int l) {
    int len=1;
    sz=0;
    while(len<l) len<<=1, ++sz;
    for(int i=1;i<len;i++) {
        inv[i]=(i==1?1:inv[mod%i]*(mod-mod/i)%mod);
        rev[i]=(rev[i>>1]>>1)|((i&1)<<(sz-1));
    }
    int wn=qpow(3,(mod-1)/len);
    w[len/2]=1;
    for(int i=len/2+1;i<len;i++) w[i]=w[i-1]*wn%mod;
    for(int i=len/2-1;i;i--) w[i]=w[i<<1];
}
int pre(int l) {int g; for(g=1;g<l;g<<=1); return g;}
void ntt(int *a,int o,int n) {
    static unsigned long long s[N];
    int t=sz-__builtin_ctz(n),x;
    for(int i=0;i<n;i++) s[rev[i]>>t]=a[i];
    for(int l=1;l<n;l<<=1) for(int i=0;i<n;i+=l<<1) for(int j=0;j<l;j++) {
        x=s[i+j+l]*w[j+l]%mod;
        s[i+j+l]=s[i+j]+mod-x;
        s[i+j]+=x;
    }
    for(int i=0;i<n;i++) a[i]=s[i]%mod;
    if(o) {
        x=qpow(n,mod-2);
        for(int i=0;i<n;i++) a[i]=a[i]*x%mod;
        reverse(a+1,a+n);
    }
}
void mult(int n,int *x,int *y,int *z) {
    static int a[N],b[N];
    int l=pre(n<<1);
    for(int i=0;i<l;i++) {
        a[i]=(i<n?x[i]:0);
        b[i]=(i<n?y[i]:0);
    }
    ntt(a,0,l); ntt(b,0,l);
    for(int i=0;i<l;i++) z[i]=a[i]*b[i]%mod;
    ntt(z,1,l);
    for(int i=n;i<l;i++) z[i]=0;
}
void inve(int len,int *a,int *b) {
    if(len==1) *b=qpow(*a,mod-2);
    else {
        inve((len+1)/2,a,b);
        static int c[N];
        int n=pre(len<<1);
        for(int i=0;i<n;i++) i<len?c[i]=a[i]:b[i]=c[i]=0;
        ntt(b,0,n);
        ntt(c,0,n);
        for(int i=0;i<n;i++) b[i]=((b[i]+b[i]-b[i]*b[i]%mod*c[i])%mod+mod)%mod;
        ntt(b,1,n);
        for(int i=len;i<n;i++) b[i]=0;
    }
}
void sqrt(int n,int *a,int *b) {
    if(n==1) *b=cipolla::calc(*a);
    else {
        sqrt((n+1)/2,a,b);
        static int c[N];
        inve(n,b,c);
        mult(n,a,c,c);
        for(int i=0;i<n;i++) b[i]=(b[i]+c[i])*inv[2]%mod;
    }
}
void deri(int n,int *a,int *b) {
    for(int i=0;i<n-1;i++) b[i]=a[i+1]*(i+1)%mod;
    b[n-1]=0;
}
void inte(int n,int *a,int *b) {
    for(int i=n-1;i>0;--i) b[i]=a[i-1]*inv[i]%mod;
    b[0]=0;
}
void loge(int n,int *a,int *b) {
    static int c[N];
    inve(n,a,b);
    deri(n,a,c);
    mult(n,b,c,b);
    inte(n,b,b);
}
void expr(int n,int *a,int *b) {
    if(n==1) *b=1;
    else {
        expr((n+1)/2,a,b);
        static int c[N];
        loge(n,b,c);
        for(int i=0;i<n;i++) c[i]=(a[i]-c[i]+mod)%mod;
        c[0]=(c[0]+1)%mod;
        mult(n,b,c,b);
    }
}
}

int n,k,a[N],b[N],c[N];

signed main() {
    ios::sync_with_stdio(false);
    cin>>n>>k;
    po::presolve((n+1)<<1);
    for(int i=0;i<=n;i++) cin>>a[i];
    po::sqrt(n+1,a,b);
    po::inve(n+1,b,c);
    po::inte(n+1,c,b);
    po::expr(n+1,b,c);
    a[0]=2;
    for(int i=0;i<=n;i++) a[i]=(mod+a[i]-c[i])%mod;
    po::loge(n+1,a,b);
    b[0]++;
    po::loge(n+1,b,c);
    for(int i=0;i<=n;i++) c[i]=c[i]*k%mod;
    po::expr(n+1,c,b);
    po::deri(n+1,b,a);
    for(int i=0;i<n;i++) cout<<a[i]<<" ";
}


```

```
7 19260817
1 9 2 6 0 8 1 7

154086536 791514529 907426922 796196275 141417382 116874127 473725705
```



## 快速莫比乌斯变换

```cpp
#include <bits/stdc++.h>
using namespace std;

double a[2000005],ans;
int n;

signed main() {
    ios::sync_with_stdio(false);
    cin>>n;
    for(int i=0;i<1<<n;i++) cin>>a[i];
    int up=1<<n;
    for(int k=1;k<up;k<<=1)
        for(int s=0;s<up;s+=k<<1)
            for(int i=s;i<s+k;i++)
            {double a0=a[i];double a1=a[i+k];a[i]=a0;a[i+k]=a0+a1;}
    for(int i=1;i<up;i++) {
        if(1-a[(up-1)^i]<1e-10) {
            puts("INF");
            return 0;
        }
        ans += (__builtin_popcount(i)%2?1:-1)*1/(1-a[(up-1)^i]);
    }
    printf("%.8lf",ans);
}
```

## 快速沃尔什变换

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int N = 1 << 17 | 1;
const int mod = 998244353;

int qpow(int p,int q)
{
    return (q&1 ? p : 1) * (q ? qpow(p*p%mod,q/2) : 1) % mod;
}

int inv(int p)
{
    return qpow(p, mod-2);
}

int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}

void rd(int &x)
{
    x=read();
}

void md(int &a)
{
    a%=mod;
    a+=mod;
    a%=mod;
}

//////////////////////////
namespace fwt
{
int n, m;
int a[N], b[N];

void load(int m, int *A, int *B)
{
    n = 1 << m;
    for (int i = 0; i < n; i++) a[i] = A[i], b[i] = B[i];
}

void get()
{
    for (int i = 0; i < n; i++) a[i] *= b[i], md(a[i]);
}

void OR(int *f, int x = 1)
{
    for (int o = 2, k = 1; o <= n; o <<= 1, k <<= 1)
        for (int i = 0; i < n; i += o)
            for (int j = 0; j < k; j++)
                f[i+j+k] += f[i+j] * x, md(f[i+j+k]);
}

void AND(int *f, int x = 1)
{
    for (int o = 2, k = 1; o <= n; o <<= 1, k <<= 1)
        for (int i = 0; i < n; i += o)
            for (int j = 0; j < k; j++)
                f[i+j] += f[i+j+k] * x, md(f[i+j]);
}

void XOR(int *f, int x = 1)
{
    for (int o = 2, k = 1; o <= n; o <<= 1, k <<= 1)
        for (int i = 0; i < n; i += o)
            for (int j = 0; j < k; j++)
                f[i+j] += f[i+j+k],
                          f[i+j+k] = f[i+j] - f[i+j+k] - f[i+j+k],
                                     md(f[i+j]), md(f[i+j+k]),
                                     f[i+j] *= x, f[i+j+k] *= x,
                                               md(f[i+j]), md(f[i+j+k]);
}

void solve_and(int m,int *A,int *B,int *c)
{
    load(m,A,B), AND(a), AND(b), get(), AND(a, mod - 1);
    memcpy(c,a,(1<<m)*sizeof(int));
}

void solve_or(int m,int *A,int *B,int *c)
{
    load(m,A,B), OR(a), OR(b), get(), OR(a, mod - 1);
    memcpy(c,a,(1<<m)*sizeof(int));
}

void solve_xor(int m,int *A,int *B,int *c)
{
    load(m,A,B), XOR(a), XOR(b), get(), XOR(a, inv(2));
    memcpy(c,a,(1<<m)*sizeof(int));
}
} // namespace fwt

int A[N], B[N], C[N];

signed main()
{
    int n, m;
    rd(m), n = 1 << m;
    for (int i = 0; i < n; i++) rd(A[i]);
    for (int i = 0; i < n; i++) rd(B[i]);

    fwt::solve_or(m,A,B,C);
    for(int i=0; i<n; i++) cout<<C[i]<<" ";
    cout<<endl;

    fwt::solve_and(m,A,B,C);
    for(int i=0; i<n; i++) cout<<C[i]<<" ";
    cout<<endl;

    fwt::solve_xor(m,A,B,C);
    for(int i=0; i<n; i++) cout<<C[i]<<" ";
    cout<<endl;

    return 0;
}

```





# 位运算

## 手工 popcount

用于需要 `long long` 或者其它玄学情况

```cpp
namespace popcnter {
    int bt[65536];
    int popcnt (int x) {
        int t=0;
        while(x>=65536){
            t+=bt[x&65535];
            x>>=16;
        }
        return t+bt[x];
    }
    void init() {
        for(int i=0;i<65536;i++) {
            bt[i]=0;
            int x=i;
            while(x) bt[i]+=(x&1),x>>=1;
        }
    }
}
```





# 组合数学

## Polya

### Description

求 $n$ 元环的 $n$ 染色方案数，旋转同构，翻转不同构，颜色可以不用完。

### Solution

根据 Polya 定理得出计算式，然后就是非常套路的推导了。

![](https://img2020.cnblogs.com/blog/1318245/202006/1318245-20200616122256029-320876592.png)

对于欧拉函数，暴力计算即可

```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long
const int N = 1000005;
const int mod = 1e+9+7;

namespace prime {
    const int MAXN = 1000005;
    bool isNotPrime[MAXN + 1];
    int mu[MAXN + 1], phi[MAXN + 1], primes[MAXN + 1], cnt, a[N];
    inline void euler() {
        isNotPrime[0] = isNotPrime[1] = true;
        mu[1] = 1;
        for (int i = 2; i <= MAXN; i++) {
            if (!isNotPrime[i]) {
                primes[++cnt] = i;
                mu[i] = -1;
            }
            for (int j = 1; j <= cnt; j++) {
                int t = i * primes[j];
                if (t > MAXN) break;
                isNotPrime[t] = true;
                if (i % primes[j] == 0) {
                    mu[t] = 0;
                    break;
                } else {
                    mu[t] = -mu[i];
                }
            }
        }
        for(int i=1;i<=cnt;i++) {
            int p=primes[i];
            for(int j=1;p*j<N;j++) {
                a[p*j]+=mu[j];
            }
        }
        for(int i=1;i<N;i++) {
            a[i]+=a[i-1];
        }
    }
}

int phi(int n) {
    int ans=n,t=n;
    for(int i=2;i*i<=n;i++) {
        if(n%i==0 && !prime::isNotPrime[i]) {
            ans=ans/i*(i-1);
            while(t%i==0) t/=i;
        }
    }
    if(t>1) ans=ans/t*(t-1);
    return ans;
}

int qpow(int p,int q) {return (q&1?p:1)*(q?qpow(p*p%mod,q/2):1)%mod;}
int inv(int p) {return qpow(p,mod-2);}

int solve(int n) {
    int ans=0;
    for(int i=1;i*i<=n;i++) {
        if(n%i==0) {
            ans+=qpow(n,i)*phi(n/i)%mod;
            if(i*i!=n) ans+=qpow(n,n/i)*phi(i)%mod;
            ans%=mod;
        }
    }
    ans*=inv(n);
    ans%=mod;
    return ans;
}

signed main() {
    int t,n;
    ios::sync_with_stdio(false);
    prime::euler();
    cin>>t;
    while(t--) {
        cin>>n;
        cout<<solve(n)<<endl;
    }
}

```



# 高精度计算

## 基本模板

``` cpp
struct Biguint {
	int a[2000005], len;

	Biguint() {
		memset(a, 0, sizeof a);
		len = 0;
	}

	void read() {
		string str;
		cin >> str;
		memset(a, 0, sizeof a);
		len = str.length();
		for (int i = 0; i < str.size(); i++)
			a[i] = str[str.length() - i - 1] - '0';
	}

	void print() {
		for (int i = len - 1; i >= 0; i--) {
			cout << a[i];
		}
	}

	bool operator < (const Biguint& obj) {
		const int* b = obj.a;
		if (this->len == obj.len) {
			for (int i = len-1; i>=0; --i)
				if (a[i] != b[i]) return a[i] < b[i];
			return false;
		}
		else return this->len < obj.len;
	}

	bool operator > (const Biguint& obj) {
		const int* b = obj.a;
		if (this->len == obj.len) {
			for (int i = len-1; i>=0; --i)
				if (a[i] != b[i]) return a[i] > b[i];
			return false;
		}
		else return this->len > obj.len;
	}

	bool operator != (const Biguint& obj) {
		return (*this < obj) | (*this > obj);
	}

	bool operator == (const Biguint& obj) {
		return !((*this < obj) | (*this > obj));
	}

	bool operator <= (const Biguint& obj) {
		return (*this) < obj || (*this) == obj;
	}

	bool operator >= (const Biguint& obj) {
		return (*this) > obj || (*this) == obj;
	}

	Biguint operator += (const Biguint& obj) {
		const int* b = obj.a;
		if (obj.len > len) len = obj.len;
		for (int i = 0; i < len; i++) {
			a[i] += b[i];
			if (a[i] >= 10) a[i + 1] += a[i] / 10, a[i] %= 10;
		}
		if (a[len]) ++len;
		while (a[len - 1] >= 10)
			a[len] += a[len - 1] / 10, a[len - 1] %= 10, ++len;
		return *this;
	}

	Biguint operator + (const Biguint& obj) {
		Biguint ret;
		ret += *this;
		ret += obj;
		return ret;
	}

	Biguint operator -= (const Biguint& obj) {
		const int* b = obj.a;
		for (int i = 0; i < len; i++) {
			a[i] -= b[i];
			if (a[i] < 0) a[i + 1]--, a[i] += 10;
		}
		while (a[len - 1] == 0 && len > 0) --len;
		return *this;
	}

	Biguint operator -(const Biguint& obj) {
		Biguint ret;
		ret += *this;
		ret -= obj;
		return ret;
	}

	Biguint operator *= (int b) {
		for (int i = 0; i < len; i++)
			a[i] *= b;
		for (int i = 0; i < len; i++)
			a[i + 1] += a[i] / 10, a[i] %= 10;
		++len;
		while (a[len - 1] >= 10)
			a[len] += a[len - 1] / 10, a[len - 1] %= 10, ++len;
		while (a[len - 1] == 0 && len > 0) --len;
		return *this;
	}

	Biguint operator * (int b) {
		Biguint ret;
		ret = *this;
		ret *= b;
		return ret;
	}

	Biguint operator * (const Biguint& obj) {
		const int* b = obj.a;
		Biguint ret;
		for (int i = 0; i < len; i++)
			for (int j = 0; j < obj.len; j++)
				ret.a[i + j] += a[i] * b[j];
		for (int i = 0; i < len + obj.len; i++)
			ret.a[i + 1] += ret.a[i] / 10, ret.a[i] %= 10;
		ret.len = len + obj.len;
		++ret.len;
		while (ret.a[ret.len - 1])
			ret.a[ret.len] += ret.a[ret.len - 1] / 10, ret.a[ret.len - 1] %= 10, ++ret.len;
		while (ret.a[ret.len - 1] == 0 && ret.len > 0) --ret.len;
		return ret;
	}

};


struct Bigint {
	Biguint a;
	bool sign;

	Bigint() {
		sign = 1;
	}

	bool operator < (const Bigint& obj) {
		if (this->sign == 1) {
			if (obj.sign == 1)
				return a < obj.a;
			else
				return 0;
		}
		else {
			if (obj.sign == 0)
				return a > obj.a;
			else
				return 1;
		}
	}

	bool operator > (const Bigint& obj) {
		if (this->sign == 1) {
			if (obj.sign == 1)
				return a > obj.a;
			else
				return 1;
		}
		else {
			if (obj.sign == 0)
				return a < obj.a;
			else
				return 0;
		}
	}

	bool operator != (const Bigint& obj) {
		return (*this < obj) | (*this > obj);
	}

	bool operator == (const Bigint& obj) {
		return !((*this < obj) | (*this > obj));
	}

	bool operator <= (const Bigint& obj) {
		return (*this) < obj || (*this) == obj;
	}

	bool operator >= (const Bigint& obj) {
		return (*this) > obj || (*this) == obj;
	}

	Bigint operator + (const Bigint& obj) {
		Bigint ret;
		if (this->sign == obj.sign) {
			ret.sign = this->sign;
			ret.a = this->a + obj.a;
		}
		else {
			if (this->a == obj.a) return ret;
			if (this->a > obj.a) {
				ret.sign = this->sign;
				ret.a = this->a - obj.a;
			}
			else {
				ret.sign = obj.sign;
				Bigint tmp = obj;
				ret.a = tmp.a - (*this).a;
			}
		}
		while (ret.a.a[ret.a.len - 1] == 0 && ret.a.len > 0) ret.a.len--;
		return ret;
	}

	Bigint operator += (const Bigint& obj) {
		(*this) = (*this) + obj;
	}

	Bigint operator - (const Bigint& obj) {
		Bigint ret, tmp;
		tmp = obj;
		tmp.sign ^= 1;
		ret = *this + tmp;
		return ret;
	}

	Bigint operator -= (const Bigint& obj) {
		(*this) = (*this) - obj;
	}

	Bigint operator * (const Bigint& obj) {
		Bigint ret;
		ret.sign = this->sign == obj.sign;
		ret.a = this->a * obj.a;
		if (ret.a.len == 0) ret.sign = 1;
		return ret;
	}

	Bigint operator *= (const Bigint& obj) {
		(*this) = (*this) * obj;
	}

};


ostream& operator << (ostream& os, Biguint num)
{
	for (int i = num.len - 1; i >= 0; --i)
		os << num.a[i];
	if (num.len == 0) os << "0";
	return os;
}

istream& operator >> (istream& is, Biguint& num)
{
	string str;
	is >> str;
	memset(num.a, 0, sizeof num.a);
	num.len = str.length();
	for (int i = 0; i < str.length(); i++)
		num.a[i] = str[str.length() - i - 1] - '0';
	return is;
}

ostream& operator << (ostream& os, Bigint num) {
	if (num.sign == 0) os << "-";
	os << num.a;
	return os;
}

istream& operator >> (istream& is, Bigint& num) {
	string str;
	is >> str;
	memset(num.a.a, 0, sizeof num.a);
	if (str[0] == '-') {
		num.a.len = str.length() - 1;
		for (int i = 0; i < str.length() - 1; i++)
			num.a.a[i] = str[str.length() - i - 1] - '0';
		num.sign = 0;
	}
	else {
		num.a.len = str.length();
		for (int i = 0; i < str.length(); i++)
			num.a.a[i] = str[str.length() - i - 1] - '0';
		num.sign = 1;
	}
	return is;
}


```



## 完整模板

``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;
const int maxlen = 100005;

class HP {
public:
    int len, s[maxlen];
    HP() { (*this) = 0; }
    HP(int inte) { (*this) = inte; }
    HP(const char *str) { (*this) = str; }
    friend ostream &operator<<(ostream &cout, const HP &x);
    HP operator=(int inte);
    HP operator=(const char *str);
    HP operator=(const HP &b);
    HP operator*(const HP &b);
    HP operator+(const HP &b);
    HP operator-(const HP &b);
    HP operator/(const HP &b);
    HP operator%(const HP &b);
    bool operator<(const HP &b);
    bool operator>(const HP &b);
    int Compare(const HP &b);
};

ostream &operator<<(ostream &cout, const HP &x) {
    for (int i = x.len; i >= 1; i--) cout << x.s[i];
    return cout;
}
HP HP::operator=(const char *str) {
    len = (int)strlen(str);
    for (int i = 1; i <= len; i++) s[i] = str[len - i] - '0';
    return *this;
}
HP HP::operator=(int inte) {
    if (inte == 0) {
        len = 1;
        s[1] = 0;
        return (*this);
    }
    for (len = 0; inte > 0;) {
        s[++len] = inte % 10;
        inte /= 10;
    }
    return *this;
}
HP HP::operator=(const HP &b) {
    len = b.len;
    for (int i = 1; i <= len; i++) s[i] = b.s[i];
    return *this;
}
HP HP::operator*(const HP &b) {
    int i, j;
    HP c;
    c.len = len + b.len;
    for (i = 1; i <= c.len; i++) c.s[i] = 0;
    for (i = 1; i <= len; i++)
        for (j = 1; j <= b.len; j++) c.s[i + j - 1] += s[i] * b.s[j];
    for (i = 1; i < c.len; i++) {
        c.s[i + 1] += c.s[i] / 10;
        c.s[i] %= 10;
    }
    while (c.s[i]) {
        c.s[i + 1] = c.s[i] / 10;
        c.s[i] %= 10;
        i++;
    }
    while (i > 1 && !c.s[i]) i--;
    c.len = i;
    return c;
}
HP HP::operator+(const HP &b) {
    int i;
    HP c;
    c.s[1] = 0;
    for (i = 1; i <= len || i <= b.len || c.s[i]; i++) {
        if (i <= len)
            c.s[i] += s[i];
        if (i <= b.len)
            c.s[i] += b.s[i];
        c.s[i + 1] = c.s[i] / 10;
        c.s[i] %= 10;
    }
    c.len = i - 1;
    if (c.len == 0)
        c.len = 1;
    return c;
}
HP HP::operator-(const HP &b) {
    int i, j;
    HP c;
    for (i = 1, j = 0; i <= len; i++) {
        c.s[i] = s[i] - j;
        if (i <= b.len)
            c.s[i] -= b.s[i];
        if (c.s[i] < 0) {
            j = 1;
            c.s[i] += 10;
        } else
            j = 0;
    }
    c.len = len;
    while (c.len > 1 && !c.s[c.len]) c.len--;
    return c;
}
int HP::Compare(const HP &y) {
    if (len > y.len)
        return 1;
    if (len < y.len)
        return -1;
    int i = len;
    while ((i > 1) && (s[i] == y.s[i])) i--;
    return s[i] - y.s[i];
}
bool HP::operator<(const HP &b) {
    if (len < b.len)
        return 1;
    if (len > b.len)
        return 0;
    int i = len;
    while ((i > 1) && (s[i] == b.s[i])) i--;
    return s[i] < b.s[i];
}
bool HP::operator>(const HP &b) {
    if (len > b.len)
        return 1;
    if (len < b.len)
        return 0;
    int i = len;
    while ((i > 1) && (s[i] == b.s[i])) i--;
    return s[i] > b.s[i];
}
HP HP::operator/(const HP &b) {
    int i, j;
    HP d(0), c;
    for (i = len; i > 0; i--) {
        if (!(d.len == 1 && d.s[1] == 0)) {
            for (j = d.len; j > 0; j--) d.s[j + 1] = d.s[j];
            ++d.len;
        }
        d.s[1] = s[i];
        c.s[i] = 0;
        while ((j = d.Compare(b)) >= 0) {
            d = d - b;
            c.s[i]++;
            if (j == 0)
                break;
        }
    }
    c.len = len;
    while ((c.len > 1) && (c.s[c.len] == 0)) c.len--;
    return c;
}
HP HP::operator%(const HP &b) {
    int i, j;
    HP d(0);
    for (i = len; i > 0; i--) {
        if (!(d.len == 1 && d.s[1] == 0)) {
            for (j = d.len; j > 0; j--) d.s[j + 1] = d.s[j];
            ++d.len;
        }
        d.s[1] = s[i];
        while ((j = d.Compare(b)) >= 0) {
            d = d - b;
            if (j == 0)
                break;
        }
    }
    return d;
}

HP a, b, c;
char s1[maxlen], s2[maxlen];

int main() {
    scanf("%s\n%s", s1, s2);
    a = s1;
    b = s2;
    c = a / b;
    cout << c << endl;
    return 0;
}

```



