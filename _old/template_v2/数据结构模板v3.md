# 数据结构

[TOC]

## 单调性数据结构

### 单调队列

``` cpp
#include <bits/stdc++.h>
using namespace std;

int n,k,a[1000005];

struct Monoqueue {
        deque <pair<int,int> > q;
        void push(int num,int tim) {
                while(q.size() && q.back().first < num)
                        q.pop_back();
                q.push_back(make_pair(num,tim));
        }
        int get(int tim) {
                while(q.size() && q.front().second < tim)
                        q.pop_front();
                if(q.size())
                        return q.front().first;
                else return 0;
        }
} q,q2;

int main() {
        scanf("%d%d",&n,&k);
        for(int i=1;i<=n;i++) scanf("%d",&a[i]);
        for(int i=1;i<k;i++) q.push(a[i], i+k-1), q2.push(-a[i], i+k-1);
        for(int i=k;i<=n;i++) {
                q2.push(-a[i], i+k-1);
                printf("%d ",-q2.get(i));
        }
        printf("\n");
        for(int i=k;i<=n;i++) {
                q.push(a[i], i+k-1);
                printf("%d ",q.get(i));
        }


}
```



### 单调栈

type c

## ST 表

### ST 表维护 RMQ

``` cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1000005;
struct st {
    int a[N][21];
    void build(int *src,int n) {
        for(int i=1;i<=n;i++) a[i][0]=src[i];
        for(int i=1;i<=20;i++)
            for(int j=1;j<=n-(1<<i)+1;j++)
                a[j][i]=max(a[j][i-1],a[j+(1<<(i-1))][i-1]);
    }
    int query(int l,int r) {
        int j=log2(r-l+1);
        return max(a[l][j],a[r-(1<<j)+1][j]);
    }
};
int n,m,a[N];
st s;
int main() {
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i];
    s.build(a,n);
    for(int i=1;i<=m;i++) {
        int u,v;
        cin>>u>>v;
        cout<<s.query(u,v)<<endl;
    }
}
```



### ST 表求 LCA

见图论模板

## DSU

### 按秩合并 DSU（带撤销）

可撤销并查集用启发式合并来优化。

用一个栈来记录合并的操作，按照逆序恢复到原来的状态。

记录一个撤销栈，元素为有序对 `<int* pElem,int nValue>`，如果撤销这个步骤则令 `*pElem=nValue` 即可。那么在启发式合并的时候，每次修改了什么就记录什么，撤销的时候删除即可。



``` cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long 
const int N = 1000005;

struct dsu 
{
    int fa[N],rank[N];
    stack<pair<int*,int>> sta;
    void init(int n)
    {
        for(int i=1;i<=n;i++) 
        {
            fa[i]=i;
            rank[i]=1;
        }
    }
    int find(int p)
    {
        return fa[p]==p ? p : find(fa[p]);
    }
    void merge(int p,int q)
    {
        p=find(p);
        q=find(q);
        if(p!=q)
        {
            if(rank[p]>rank[q]) swap(p,q);
            sta.push({fa+p,fa[p]});
            fa[p]=q;
            if(rank[p]==rank[q])
            {
                sta.push({rank+q,rank[q]});
                ++rank[q];
            }
            else
            {
                sta.push({NULL,0});
            }
        }
    }
    void _undo()
    {
        if(sta.size()==0) return;
        if(sta.top().first!=NULL)
        {
            *sta.top().first=sta.top().second;
        }
        sta.pop();
    }
    void undo()
    {
        _undo();
        _undo();
    }
    void print(int n)
    {
        cout<<" FA[] = ";
        for(int i=1;i<=n;i++)
        {
            cout<<fa[i]<<" ";
        }
        cout<<endl;
    }
} dsu;

signed main()
{
    int n;
    cin>>n;
    dsu.init(n);
    while(true)
    {
        string op;
        int t1,t2;
        cin>>op;
        if(op=="merge")
        {
            cin>>t1>>t2;
            dsu.merge(t1,t2);
        }
        if(op=="undo")
        {
            dsu.undo();
        }
        dsu.print(n);
    }
}
```

### 种类 DSU（引用）

一般的并查集，维护的是具有连通性、传递性的关系，例如**亲戚的亲戚是亲戚**。但是，有时候，我们要维护另一种关系：**敌人的敌人是朋友**。种类并查集就是为了解决这个问题而诞生的。

我们先来看一个例题：

> **题目描述**
> ![[公式]](https://www.zhihu.com/equation?tex=S+) 城现有两座监狱，一共关押着 ![[公式]](https://www.zhihu.com/equation?tex=N) 名罪犯，编号分别为 ![[公式]](https://www.zhihu.com/equation?tex=1-N) 。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 ![[公式]](https://www.zhihu.com/equation?tex=c) 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 ![[公式]](https://www.zhihu.com/equation?tex=c) 的冲突事件。
> 每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到S 城Z 市长那里。公务繁忙的Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。
> 在详细考察了 ![[公式]](https://www.zhihu.com/equation?tex=N) 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。
> 那么，应如何分配罪犯，才能使Z市长看到的那个冲突事件的影响力最小？这个最小值是多少？
> **输入格式**
> 每行中两个数之间用一个空格隔开。第一行为两个正整数 ![[公式]](https://www.zhihu.com/equation?tex=N%2C+M) ，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的M*M*行每行为三个正整数 ![[公式]](https://www.zhihu.com/equation?tex=a_j%2Cb_j%2Cc_j) ，表示![[公式]](https://www.zhihu.com/equation?tex=a_j) 号和 ![[公式]](https://www.zhihu.com/equation?tex=b_j) 号罪犯之间存在仇恨，其怨气值为 ![[公式]](https://www.zhihu.com/equation?tex=c_j) 。数据保证 ![[公式]](https://www.zhihu.com/equation?tex=1%3Ca_j%E2%89%A4b_j%E2%89%A4N+%2C0+%3C+c_j%E2%89%A4+1%2C000%2C000%2C000) ，且每对罪犯组合只出现一次。
> **输出格式**
> 共1行，为Z市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出0。

其实很容易想到，这里可以**贪心**，把所有矛盾关系**从大到小**排个序，然后尽可能地把矛盾大的犯人关到不同的监狱里，直到不能这么做为止。这看上去可以用并查集维护，但是有一个问题：我们得到的信息，不是哪些人应该在**相同**的监狱，而是哪些人应该在**不同**的监狱。这怎么处理呢？这个题其实有很多做法，但这里，我们介绍使用种类并查集的做法。

------

我们开一个**两倍大小**的并查集。例如，假如我们要维护4个元素的并查集，我们改为开8个单位的空间：

![img](https://pic1.zhimg.com/80/v2-5feedf33c0a79e6a2098add6726db040_720w.jpg)

我们用1~4维护**朋友**关系（就这道题而言，是指关在同一个监狱的狱友），用5~8维护**敌人**关系（这道题里是指关在不同监狱的仇人）。现在假如我们得到信息：1和2是敌人，应该怎么办？

我们`merge(1, 2+n), merge(1+n, 2);`。这里n就等于4，但我写成n这样更清晰。对于1个编号为i的元素，i+n是它的敌人。所以这里的意思就是：1是2的敌人，2是1的敌人。

![img](https://pic3.zhimg.com/80/v2-9365b0af4ade508a0f1461cfec37f7d2_720w.jpg)

现在假如我们又知道2和4是敌人，我们`merge(2, 4+n), merge(2+n, 4);`：

![img](https://pic1.zhimg.com/80/v2-d86d178ed411c7c0d98402359efe5360_720w.jpg)

发现了吗，**敌人的敌人就是朋友**，2和4是敌人，2和1也是敌人，所以这里，1和4通过2+n这个元素**间接**地连接起来了。这就是种类并查集工作的原理。

代码如下：

```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>
int read() //快速读入，可忽略
{
    int ans = 0;
    char c = getchar();
    while (!isdigit(c))
        c = getchar();
    while (isdigit(c))
    {
        ans = (ans << 3) + (ans << 1) + c - '0';
        c = getchar();
    }
    return ans;
}
struct data  //以结构体方式保存便于排序
{
    int a, b, w;
} C[100005];
int cmp(data &a, data &b)
{
    return a.w > b.w;
}
int fa[40005], rank[40005];  //以下为并查集
int find(int a)
{
    return (fa[a] == a) ? a : (fa[a] = find(fa[a]));
}
int query(int a, int b)
{
    return find(a) == find(b);
}
void merge(int a, int b)
{
    int x = find(a), y = find(b);
    if (rank[x] >= rank[y])
        fa[y] = x;
    else
        fa[x] = y;
    if (rank[x] == rank[y] && x != y)
        rank[x]++;
}
void init(int n)
{
    for (int i = 1; i <= n; ++i)
    {
        rank[i] = 1;
        fa[i] = i;
    }
}
int main()
{
    int n = read(), m = read();
    init(n * 2); //对于罪犯i，i+n为他的敌人
    for (int i = 0; i < m; ++i)
    {
        C[i].a = read();
        C[i].b = read();
        C[i].w = read();
    }
    std::sort(C, C + m, cmp);
    for (int i = 0; i < m; ++i)
    {
        if (query(C[i].a, C[i].b))  //试图把两个已经被标记为“朋友”的人标记为“敌人”
        {
            printf("%d\n", C[i].w); //此时的怒气值就是最大怒气值的最小值
            break;
        }
        merge(C[i].a, C[i].b + n);
        merge(C[i].b, C[i].a + n);
        if (i == m - 1)  //如果循环结束仍无冲突，输出0
            puts("0");
    }
    return 0;
}
```

## 树状数组

``` cpp
// 1D
const int N = 10000;
int ar[N]; // index: 1 ~ N
int lowbit(int t) { return t & (-t); }
void add(int i, int v) {
	for (; i < N; ar[i] += v, i += lowbit(i));
}
int sum(int i) {
	int s = 0;
	for (; i > 0; s += ar[i], i -= lowbit(i));
	return s;
}

// 2D
int c[N][N]; int Row, Col;
inline int lowbit(const int& x) {// x > 0
	return x & (-x);
}
int Sum(int i, int j) {
	int tmp, sum = 0;
	while (i > 0) {
		tmp = j;
		while (tmp > 0) {
			sum += c[i][tmp];
			tmp -= lowbit(tmp);
		}
		i -= lowbit(i);
	}
	return sum;
}
void Update(int i, int j, int num) {
	int tmp;
	while (i <= Row) {
		tmp = j;
		while (tmp <= Col) {
			c[i][tmp] += num;
			tmp += lowbit(tmp);
		}
		i += lowbit(i);
	}
}

```

KTH

``` cpp
int findkth(int k){
    int ans=0,cnt=0;
    for (int i=20;i>=0;--i){
        ans+=1<<i;
        if (ans>=n||cnt+c[ans]>=k)ans-=1<<i;
        else cnt+=c[ans];
    }
    return ans+1;
}
```



## 主席树与树套树

### 静态区间第 k 大

``` cpp
int n,m,t1,t2,t3,k,a[2000005],b[2000005],c[8000005],d[8000005],e[8000005],f,g[2000005],q[2000005],s,h[2000005]={1,0};
int build(int l,int r){
    int p=++f;
    if(r==l) c[p]=0;
    else d[p]=build(l,(l+r)/2), e[p]=build((l+r)/2+1,r);
    return p;}
void pushup(int p){c[p]=c[d[p]]+c[e[p]];}
int modify(int j,int l,int r,int k){
    int p=++f; c[p]=c[j]; d[p]=d[j]; e[p]=e[j];
    if(l==r) {c[p]++; return p;}
    if(k<=(l+r)/2) d[p]=modify(d[j],l,(l+r)/2,k);
    else e[p]=modify(e[j],(l+r)/2+1,r,k);
    pushup(p); return p;}
int query(int i,int j,int l,int r,int k){
    if(l==r) return l;
    if(k<=c[d[j]]-c[d[i]]) return query(d[i],d[j],l,(l+r)/2,k);
    else return query(e[i],e[j],(l+r)/2+1,r,k-(c[d[j]]-c[d[i]]));}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]), h[i]=a[i];
    sort(a+1,a+n+1); s=unique(a+1,a+n+1)-a-1;
    for(int i=1;i<=n;i++) q[i]=lower_bound(a+1,a+s+1,h[i])-a;
    build(1,s); g[0]=1;
    for(int i=1;i<=n;i++) g[i]=modify(g[i-1],1,s,q[i]);
    for(int i=1;i<=m;i++)
        scanf("%d%d%d",&t1,&t2,&k),
        printf("%d\n",a[query(g[t1-1],g[t2],1,s,k)]);
}
```



### 动态区间第 k 大

``` cpp
#include <bits/stdc++.h>
using namespace std;

int a[10000005],b[10000005],ch[10000005][2],chb[10000005][2],src[100005],ind,idx,InnerSize,t1,t2,t3,t4,n,m,root;
char str[10];
const int Inf = 1000000007;

void inner_modify(int &p,int l,int r,int pos,int key){
        if(!p) p=++ind;
        //printf("inner_modify %d %d %d %d %d\n",p,l,r,pos,key);
        a[p]+=key;
        if(l-r){
                if(pos<=(l+r)/2){
                        inner_modify(ch[p][0],l,(l+r)/2,pos,key);
                }
                else{
                        inner_modify(ch[p][1],(l+r)/2+1,r,pos,key);
                }
        }
}

int inner_query(int p,int l,int r,int ql,int qr){
        //printf("inner_query %d %d %d %d %d\n",p,l,r,ql,qr);
        if(!p) return 0;
        if(l>qr||r<ql) return 0;
        if(l>=ql&&r<=qr) return a[p];
        return inner_query(ch[p][0],l,(l+r)/2,ql,qr)+inner_query(ch[p][1],(l+r)/2+1,r,ql,qr);
}

void outer_modify(int &p,int l,int r,int pos,int inner_pos,int inner_key){
        if(!p) p=++idx;
        //printf("outer_modify %d %d %d %d %d %d\n",p,l,r,pos,inner_pos,inner_key);
        inner_modify(b[p],1,n,inner_pos,inner_key);
        if(l-r){
                if(pos<=(l+r)/2){
                        outer_modify(chb[p][0],l,(l+r)/2,pos,inner_pos,inner_key);
                }
                else{
                        outer_modify(chb[p][1],(l+r)/2+1,r,pos,inner_pos,inner_key);
                }
        }
}

int outer_query(int p,int l,int r,int lb,int rb,int k){
        //printf("outer_query %d %d %d %d %d %d \n",p,l,r,lb,rb,k);
        int res=inner_query(b[chb[p][0]],1,n,lb,rb);
        if(l==r) return r;
        if(res>=k) return outer_query(chb[p][0],l,(l+r)/2,lb,rb,k);
        else return outer_query(chb[p][1],(l+r)/2+1,r,lb,rb,k-res);
}

int main(){
        scanf("%d%d",&n,&m);
        for(int i=1;i<=n;i++){
                scanf("%d",&src[i]);
                outer_modify(root,1,Inf,src[i],i,1);
        }
        for(int i=1;i<=m;i++){
                scanf("%s%d%d",&str,&t1,&t2);
                if(str[0]=='Q'){
                        scanf("%d",&t3);
                        printf("%d\n",outer_query(root,1,Inf,t1,t2,t3));
                }
                else{
                        outer_modify(root,1,Inf,src[t1],t1,-1);
                        outer_modify(root,1,Inf,t2,t1,1);
                        src[t1]=t2;
                }
        }
}
```





## 李超线段树

``` cpp
namespace seg {
const int N = 4e6+5;
#define lc x<<1
#define rc x<<1|1
#define mid ((l+r)>>1)
struct Node {
    int a,b;
} tree[N];
void ins(int x,int l,int r,int a,int b) {
    if(tree[x].a*l+tree[x].b<=a*l+b&&tree[x].a*r+tree[x].b<=a*r+b)  {
        tree[x].a=a,tree[x].b=b;
    }
    else {
        if(tree[x].a*l+tree[x].b>=a*l+b&&tree[x].a*r+tree[x].b>=a*r+b) return;
        if(tree[x].a*mid+tree[x].b<a*mid+b)swap(tree[x].a,a),swap(tree[x].b,b);
        if(a<tree[x].a)ins(lc,l,mid,a,b);
        else ins(rc,mid+1,r,a,b);
    }
}
void build(int x,int l,int r) {
    tree[x].a=tree[x].b=0;
    if(l==r)return;
    build(lc,l,mid);
    build(rc,mid+1,r);
}
int query(int x,int l,int r,int p) {
    int ans=tree[x].a*p+tree[x].b;
    if(l==r)return ans;
    if(p<=mid)ans=max(ans,query(lc,l,mid,p));
    else ans=max(ans,query(rc,mid+1,r,p));
    return ans;
}
};
```



## Splay

### 普通平衡树操作

``` cpp
#include <bits/stdc++.h>
using namespace std;
const int SN = 200005;
struct SplayTree {
        int k[SN], sz[SN], cnt[SN], fa[SN], ch[SN][2], ind, root;
        SplayTree() {
                memset(k, 0, sizeof k);
                memset(sz, 0, sizeof sz);
                memset(cnt, 0, sizeof cnt);
                memset(fa, 0, sizeof fa);
                memset(ch, 0, sizeof ch);
                ind = 0; root = 0;
        }
        void pushup(int p) {
                sz[p] = sz[ch[p][0]] + sz[ch[p][1]] + cnt[p];
        }
        void rotate(int p) {
                int q = fa[p], y = fa[q], x = ch[q][1] == p;
                ch[q][x] = ch[p][x ^ 1]; fa[ch[q][x]] = q;
                ch[p][x ^ 1] = q; fa[q] = p; fa[p] = y;
                if (y) ch[y][ch[y][1] == q] = p;
                pushup(q); pushup(p);
        }
        void splay(int x) {
                for (int y; y = fa[x]; rotate(x))
                        if (fa[y]) rotate((ch[fa[y]][0] == y) == (ch[y][0] == x) ? y : x);
                root = x;
        }
        int search(int v) {
                int p = root;
                while (p && (k[p] - v)) p = ch[p][k[p] < v];
                return p;
        }
        void insert(int v) {
                if (root == 0) {
                        root = ++ind;
                        k[root] = v;
                        sz[root] = cnt[root] = 1;
                }
                else if (search(v)) {
                        int tmp = search(v);
                        splay(tmp);
                        sz[tmp]++; cnt[tmp]++;
                }
                else {
                        int p = root;
                        while (p && ch[p][k[p] < v]) p = ch[p][k[p] < v];
                        ch[p][k[p] < v] = ++ind;
                        fa[ind] = p;
                        k[ind] = v; sz[ind] = cnt[ind] = 1;
                        splay(ind);
                }
        }
        void remove(int p) {
                if (p == 0) return;
                splay(p);
                if (cnt[p] > 1) { cnt[p]--; sz[p]--; return; }
                int l = ch[p][0], r = ch[p][1];
                fa[l] = fa[r] = 0; ch[p][0] = ch[p][1] = 0;
                if (l == 0) { root = r; return; }
                if (r == 0) { root = l; return; }
                int t = l;
                while (t && ch[t][1]) t = ch[t][1];
                root = l; splay(t);
                ch[t][1] = r; fa[r] = t;
                pushup(t);
        }
        void remove_v(int v) {
                remove(search(v));
        }
        int rank(int p) {
                splay(p);
                return sz[ch[p][0]] + 1;
        }
        int rank_v(int v) {
                return rank(search(v));
        }
        int kth(int p, int k) {
                if (k <= sz[ch[p][0]]) return kth(ch[p][0], k);
                if (k <= sz[ch[p][0]] + cnt[p]) return p;
                else return kth(ch[p][1], k - sz[ch[p][0]] - cnt[p]);
        }
        int kth(int k0) {
                return kth(root, k0);
        }
        int kth_v(int k0) {
                return k[kth(k0)];
        }
        int prefix(int p) {
                splay(p);
                int t = ch[p][0];
                while (t && ch[t][1]) t = ch[t][1];
                return t;
        }
        int prefix_v(int v) {
                insert(v);
                int r_ans = prefix(search(v));
                remove(search(v));
                return k[r_ans];
        }
        int suffix(int p) {
                splay(p);
                int t = ch[p][1];
                while (t && ch[t][0]) t = ch[t][0];
                return t;
        }
        int suffix_v(int v) {
                insert(v);
                int r_ans = suffix(search(v));
                remove(search(v));
                return k[r_ans];
        }
} T;
```



### 区间翻转

``` cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1000005;
int k[N], sz[N], ch[N][2], fa[N], n, m, t1, t2, t3, t4, rev[N], ind, root;

void pushup(int p) {
	sz[p] = sz[ch[p][0]] + sz[ch[p][1]] + 1;
}

void pushdown(int p) {
	if (rev[p]) {
		rev[ch[p][0]] ^= 1;
		rev[ch[p][1]] ^= 1;
		rev[p] ^= 1;
		swap(ch[p][0], ch[p][1]);
	}
}

void rotate(int p, int& k) {
	int q = fa[p], y = fa[q], x = ch[q][1] == p;
	if (y) pushdown(y);
	pushdown(q); pushdown(p);
	ch[q][x] = ch[p][x ^ 1]; fa[ch[q][x]] = q;
	ch[p][x ^ 1] = q; fa[q] = p; fa[p] = y;
	if (q != k) {
		if (y)if (ch[y][0] == q) ch[y][0] = p;
		else if (ch[y][1] == q) ch[y][1] = p;
	}
	else k = p;
	pushup(q); pushup(p);
}

void splay(int x, int& k) {
	for (int y = fa[x]; x != k; rotate(x, k), y = fa[x])
		if (y != k)
			rotate((ch[fa[y]][0] == y) == (ch[y][0] == x) ? y : x, k);
}

void insert(int v) {
	if (root == 0) {
		root = ++ind;
		k[root] = v;
		sz[root] = 1;
	}
	else {
		int p = root;
		while (p && ch[p][k[p] < v])
			p = ch[p][k[p] < v];
		ch[p][k[p] < v] = ++ind;
		fa[ind] = p;
		sz[ind] = 1;
		k[ind] = v;
		splay(ind, root);
	}
}

int kth(int p, int k) {
	if (p == 0 || k == 0) return 0;
	pushdown(p);
	if (k <= sz[ch[p][0]]) return kth(ch[p][0], k);
	if (k == sz[ch[p][0]] + 1) return p;
	return kth(ch[p][1], k - sz[ch[p][0]] - 1);
}

int nodesplit(int l, int r) {
	if (l) {
		splay(l, root);
		if (r) {
			splay(r, ch[l][1]);
			return ch[r][0];
		}
		else return ch[l][1];
	}
	else
		if (r) {
			splay(r, root);
			return ch[r][0];
		}
		else return root;
}

int split(int l, int r) {
	return nodesplit(kth(root, l - 1), kth(root, r + 1));
}

void reverse(int l, int r) {
	int tmp = split(l, r);
	rev[tmp] ^= 1;
}

void print(int p) {
	if (p == 0) return;
	pushdown(p);
	print(ch[p][0]);
	cout << k[p] << " ";
	print(ch[p][1]);
}

void print() {
	print(root);
	cout << endl;
}

int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) insert(i);
	for (int i = 1; i <= m; i++)
		cin >> t1 >> t2,
		reverse(t1, t2);
	print();
}
```



### 启发式合并

``` cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;

int seq[100005], s0[100005], n, m, cnta[100005], tmp, root[100005], f[100005], ind, k[1000005], ch[1000005][2], fa[1000005], tsize[1000005], us0[100005], red[100005], mp[1000005], t1, t2, t3;

int ufs_find(int p) {
	int t = p, tt = p, ttt;
	while (t - f[t] && f[t] && t) t = f[t];
	while (tt - f[tt] && f[tt] && tt) ttt = f[tt], f[tt] = t, tt = ttt;
	return t;
}

void ufs_union(int sp, int sq) { // union p to q
	int p = ufs_find(sp), q = ufs_find(sq);
	if (p - q) f[p] = q;
}

void rotate(int p) {
	int q = fa[p], y = fa[q], x = ch[q][1] == p;
	ch[q][x] = ch[p][x ^ 1]; fa[ch[q][x]] = q;
	ch[p][x ^ 1] = q; fa[q] = p; fa[p] = y;
	if (y)if (ch[y][0] == q) ch[y][0] = p;
	else if (ch[y][1] == q) ch[y][1] = p;
}

void splay(int x, int tid) {
	for (int y = fa[x]; y = fa[x]; rotate(x))
		if (fa[y])rotate((ch[y][0] == x) == (ch[fa[y]][0] == y) ? y : x);
	root[tid] = x;
}

void insert(int x, int tid) {
	if (root[tid] == 0) root[tid] = ++ind, k[ind] = x, tsize[tid]++;
	else {
		int p = root[tid], tp = root[tid];
		while (p && tp) p = tp, tp = ch[p][k[p] < x];
		ch[p][k[p] < x] = ++ind; k[ind] = x; fa[ind] = p;
		splay(ind, tid); tsize[tid]++;
	}
}

void merge(int p, int tid) {
	if (p == 0) return;
	insert(k[p], tid);
	if (ch[p][0]) merge(ch[p][0], tid);
	if (ch[p][1]) merge(ch[p][1], tid);
}

void print(int p) {
	if (p == 0) return;
	print(ch[p][0]);
	printf("%d ", k[p]);
	print(ch[p][1]);
}

int findmin(int p) {
	int x = p;
	while (ch[x][0] && x) x = ch[x][0];
	return x;
}

void remove(int p, int tid) {
	if (p == 0)return;
	splay(p, tid);
	int lr = ch[p][0], rr = ch[p][1];
	if (lr == 0) { root[tid] = rr, fa[rr] = 0; return; }
	int tm = lr;
	root[tid] = lr;
	while (tm && ch[tm][1]) tm = ch[tm][1];
	if (tm) splay(tm, tid);
	ch[root[tid]][1] = rr; fa[rr] = root[tid];
}

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", &seq[i]), s0[i] = seq[i];
	sort(seq + 1, seq + n + 1);
	for (int i = 1; i <= n; i++) s0[i] = lower_bound(seq + 1, seq + n + 1, s0[i]) - seq;
	for (int i = 1; i <= n; i++) tmp = s0[i], s0[i] += cnta[s0[i]], cnta[tmp]++;
	for (int i = 1; i <= n; i++) insert(s0[i], i), f[i] = i, us0[s0[i]] = i;
	for (int i = 1; i <= m; i++) {
		scanf("%d%d", &t1, &t2);
		if (t1 == 1) {
			scanf("%d", &t3);
			if (red[t2] || red[t3]) goto Next;
			t2 = ufs_find(t2); t3 = ufs_find(t3);
			if (tsize[t2] > tsize[t3]) { int tmp = t2; t2 = t3; t3 = tmp; }
			ufs_union(t2, t3); merge(root[t2], t3);
		}
		else {
			if (red[t2]) { printf("-1\n"); goto Next; }
			t2 = ufs_find(t2);
			int t = findmin(root[t2]);
			if (tsize[t2] == 0) { printf("-1\n"); goto Next; }
			printf("%d\n", seq[k[t]]);
			remove(t, t2); red[us0[k[t]]] = 1; tsize[t2]--;
		}
	Next:;
	}
}

```



## 树链剖分

### 点权版

``` cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int N = 400005;

int val[N],tag[N];

void pushup(int p) {
    val[p]=val[p*2]+val[p*2+1];
}
void pushdown(int p,int l,int r) {
    if(tag[p]) {
        val[p*2]+=tag[p]*((l+r)/2-l+1);
        val[p*2+1]+=tag[p]*(r-(l+r)/2);
        tag[p*2]+=tag[p];
        tag[p*2+1]+=tag[p];
        tag[p]=0;
    }
}
void build(int p,int l,int r,int *src) {
    if(l==r) val[p]=src[l];
    else {
        build(p*2,l,(l+r)/2,src);
        build(p*2+1,(l+r)/2+1,r,src);
        pushup(p);
    }
}
void modify(int p,int l,int r,int ql,int qr,int key) {
    if(l>qr || r<ql) return;
    if(l>=ql && r<=qr) {
        val[p]+=(r-l+1)*key;
        tag[p]+=key;
    }
    else {
        pushdown(p,l,r);
        modify(p*2,l,(l+r)/2,ql,qr,key);
        modify(p*2+1,(l+r)/2+1,r,ql,qr,key);
        pushup(p);
    }
}
int query(int p,int l,int r,int ql,int qr) {
    if(l>qr || r<ql) return 0;
    if(l>=ql && r<=qr) {
        return val[p];
    }
    else {
        pushdown(p,l,r);
        return query(p*2,l,(l+r)/2,ql,qr)+query(p*2+1,(l+r)/2+1,r,ql,qr);
    }
}

vector <int> g[N];

int top[N],wson[N],siz[N],dep[N],vis[N],tid[N],did[N],fin[N],fa[N],cnt=0;

void link(int p,int q) {
    g[p].push_back(q);
    g[q].push_back(p);
}

void dfs1(int p) {
    vis[p]=siz[p]=1;
    for(int q:g[p]) if(vis[q]==0) {
        dep[q]=dep[p]+1;
        fa[q]=p;
        dfs1(q);
        siz[p]+=siz[q];
        if(siz[q]>siz[wson[p]]) wson[p]=q;
    }
}

void dfs2(int p) {
    did[p]=++cnt;
    tid[cnt]=p;
    vis[p]=1;
    if(wson[p]) top[wson[p]]=top[p],dfs2(wson[p]);
    for(int q:g[p]) if(vis[q]==0) {
        top[q]=q;
        dfs2(q);
    }
    fin[p]=cnt;
}

int n,m,r,mod,v[N],w[N];

void presolve() {
    dep[r]=1;
    dfs1(r);
    memset(vis,0,sizeof vis);
    top[r]=r;
    dfs2(r);
}



void link_modify(int p,int q,int v) {
    while(top[p]-top[q]) {
        if(dep[top[p]]>dep[top[q]]) swap(p,q);
        modify(1,1,n,did[top[q]],did[q],v);
        q=fa[top[q]];
    }
    if(dep[p]>dep[q]) swap(p,q);
    modify(1,1,n,did[p],did[q],v);
}

int link_query(int p,int q) {
    int ans=0;
    while(top[p]-top[q]) {
        if(dep[top[p]]>dep[top[q]]) swap(p,q);
        ans+=query(1,1,n,did[top[q]],did[q]);
        q=fa[top[q]];
    }
    if(dep[p]>dep[q]) swap(p,q);
    ans+=query(1,1,n,did[p],did[q]);
    return ans;
}

signed main() {
    ios::sync_with_stdio(false);
    cin>>n>>m>>r>>mod;
    for(int i=1;i<=n;i++) cin>>v[i];
    for(int i=1;i<n;i++) {
        int t1,t2;
        cin>>t1>>t2;
        link(t1,t2);
    }
    presolve();
    for(int i=1;i<=n;i++) w[did[i]]=v[i];
    build(1,1,n,w);
    for(int i=1;i<=m;i++) {
        int t1,t2,t3,t4;
        cin>>t1;
        if(t1==1) {
            cin>>t2>>t3>>t4;
            link_modify(t2,t3,t4);
        }
        if(t1==2) {
            cin>>t2>>t3;
            cout<<link_query(t2,t3)%mod<<endl;
        }
        if(t1==3) {
            cin>>t2>>t3;
            modify(1,1,n,did[t2],fin[t2],t3);
        }
        if(t1==4) {
            cin>>t2;
            cout<<query(1,1,n,did[t2],fin[t2])%mod<<endl;
        }
    }
}
```







## LCT

### 维护连通性

``` cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1000000;

int n,m,val[N];

struct LinkCutTree{
	int top, q[N], ch[N][2], fa[N], xr[N], rev[N];
	inline void pushup(int x){
		xr[x]=xr[ch[x][0]]^xr[ch[x][1]]^val[x];
	}
	inline void pushdown(int x){
		if(!rev[x]) return;
		rev[ch[x][0]]^=1;
		rev[ch[x][1]]^=1;
		rev[x]^=1;
		swap(ch[x][0],ch[x][1]);
	}
	inline bool isroot(int x){
		return ch[fa[x]][0]!=x && ch[fa[x]][1]!=x;
	}
	inline void rotate(int p){
		int q=fa[p], y=fa[q], x=ch[fa[p]][1]==p;
		ch[q][x]=ch[p][x^1]; fa[ch[q][x]]=q;
		ch[p][x^1]=q; fa[q]=p; fa[p]=y;
		if(y) if(ch[y][0]==q) ch[y][0]=p;
		else  if(ch[y][1]==q) ch[y][1]=p;
		pushup(q); pushup(p);
	}
	inline void splay(int x){
		q[top=1]=x;
		for(int i=x;!isroot(i);i=fa[i]) q[++top]=fa[i];
		for(int i=top;i;i--) pushdown(q[i]);
		for(;!isroot(x);rotate(x))
			if(!isroot(fa[x]))
				rotate((ch[fa[x]][0]==x)==(ch[fa[fa[x]]][0]==fa[x])?fa[x]:x);
	}
	void access(int x){
		for(int t=0;x;t=x,x=fa[x])
			splay(x),ch[x][1]=t,pushup(x);
	}
	void makeroot(int x){
		access(x);
		splay(x);
		rev[x]^=1;
	}
	int find(int x){
		access(x);
		splay(x);
		while(ch[x][0]) x=ch[x][0];
		return x;
	}
	void split(int x,int y){
		makeroot(x);
		access(y);
		splay(y);
	}
	void cut(int x,int y){
		split(x,y);
		if(ch[y][0]==x)
			ch[y][0]=0, fa[x]=0;
	}
	void link(int x,int y){
		makeroot(x);
		fa[x]=y;
	}
} T;

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		char str[10]; int t1,t2;
		scanf("%s%d%d",&str,&t1,&t2);
		if(str[0]=='C')
			if(T.find(t1)-T.find(t2)) T.link(t1,t2);
		if(str[0]=='D')
			T.cut(t1,t2);
		if(str[0]=='Q')
			printf("%s\n",T.find(t1)-T.find(t2)?"No":"Yes");
	}
}

```

### 维护最大生成树

[NOI2014] 魔法森林

``` cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1000000;

int n,m,val[N];

namespace lct {
	int top, q[N], ch[N][2], fa[N], rev[N];
	int mx[N];
	inline void pushup(int x){
		int v=max(val[x], max( val[mx[ch[x][0]]],val[mx[ch[x][1]]] ));
		if(v==val[x]) mx[x]=x;
		else if(v==val[mx[ch[x][0]]]) mx[x]=mx[ch[x][0]];
		else mx[x]=mx[ch[x][1]];
	}
	inline void pushdown(int x){
		if(!rev[x]) return;
		rev[ch[x][0]]^=1;
		rev[ch[x][1]]^=1;
		rev[x]^=1;
		swap(ch[x][0],ch[x][1]);
	}
	inline bool isroot(int x){
		return ch[fa[x]][0]!=x && ch[fa[x]][1]!=x;
	}
	inline void rotate(int p){
		int q=fa[p], y=fa[q], x=ch[fa[p]][1]==p;
		ch[q][x]=ch[p][x^1]; fa[ch[q][x]]=q;
		ch[p][x^1]=q; fa[q]=p; fa[p]=y;
		if(y) if(ch[y][0]==q) ch[y][0]=p;
		else  if(ch[y][1]==q) ch[y][1]=p;
		pushup(q); pushup(p);
	}
	inline void splay(int x){
		q[top=1]=x;
		for(int i=x;!isroot(i);i=fa[i]) q[++top]=fa[i];
		for(int i=top;i;i--) pushdown(q[i]);
		for(;!isroot(x);rotate(x))
			if(!isroot(fa[x]))
				rotate((ch[fa[x]][0]==x)==(ch[fa[fa[x]]][0]==fa[x])?fa[x]:x);
	}
	void access(int x){
		for(int t=0;x;t=x,x=fa[x])
			splay(x),ch[x][1]=t,pushup(x);
	}
	void makeroot(int x){
		access(x);
		splay(x);
		rev[x]^=1;
	}
	int find(int x){
		access(x);
		splay(x);
		while(ch[x][0]) x=ch[x][0];
		return x;
	}
	bool islinked(int x,int y) {
        return find(x)==find(y);
	}
	void split(int x,int y){
		makeroot(x);
		access(y);
		splay(y);
	}
	void cut(int x,int y){
		split(x,y);
		if(ch[y][0]==x)
			ch[y][0]=0, fa[x]=0;
	}
	void link(int x,int y){
		makeroot(x);
		fa[x]=y;
	}
	int query(int x,int y) {
        split(x,y);
        return mx[y];
	}
}

struct edge {
    int id,u,v,a,b;
    bool operator < (const edge &x) {
        return a < x.a;
    }
} e[N];

namespace mst {
    void add(edge ee) {
        val[ee.id+n]=ee.b;
        if(lct::islinked(ee.u,ee.v)) {
            int mx=lct::query(ee.u,ee.v);
            if(val[mx]>ee.b) {
                lct::cut(mx,e[mx-n].u);
                lct::cut(mx,e[mx-n].v);
                lct::link(ee.id+n,ee.u);
                lct::link(ee.id+n,ee.v);
            }
        }
        else {
            lct::link(ee.id+n,ee.u);
            lct::link(ee.id+n,ee.v);
        }
    }
    int getans() {
        return val[lct::query(1,n)];
    }
}

signed main() {
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=m;i++) {
        edge &ee = e[i];
        cin>>ee.u>>ee.v>>ee.a>>ee.b;
    }
    sort(e+1,e+m+1);
    for(int i=1;i<=m;i++) e[i].id=i;
    int ans=1e9;
    for(int i=1;i<=m;i++) {
        mst::add(e[i]);
        if(lct::islinked(1,n)) {
            ans=min(ans,mst::getans()+e[i].a);
        }
    }
    if(ans==1e9) cout<<-1;
    else cout<<ans;
}

```



### 维护子树信息

对 lct 上每个结点，维护两个 sz 和 si，前者维护该点的信息和，后者维护该点所有虚儿子的信息

那么显然有

si[x] = sum(sz[pson]) 

sz[x]=sz[lson]+sz[rson]+si[x]+v[x]

其中 pson 是虚儿子，lson,rson 是 LCT 上的实儿子，v是结点本身

access 操作时，将旧虚儿子从 si 中减去，将新虚儿子加入

link f[x]=y 后，将 x 的信息计入 si[y] 中

pushup 时，按照上述公式更新一下即可

``` cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1000000;

int n,m,val[N];

namespace lct{
	int top, q[N], ch[N][2], fa[N], rev[N];
	int sz[N], si[N];
	inline void pushup(int x){
		sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+si[x]+1; //
	}
	inline void pushdown(int x){
		if(!rev[x]) return;
		rev[ch[x][0]]^=1;
		rev[ch[x][1]]^=1;
		rev[x]^=1;
		swap(ch[x][0],ch[x][1]);
	}
	inline bool isroot(int x){
		return ch[fa[x]][0]!=x && ch[fa[x]][1]!=x;
	}
	inline void rotate(int p){
		int q=fa[p], y=fa[q], x=ch[fa[p]][1]==p;
		ch[q][x]=ch[p][x^1]; fa[ch[q][x]]=q;
		ch[p][x^1]=q; fa[q]=p; fa[p]=y;
		if(y) if(ch[y][0]==q) ch[y][0]=p;
		else  if(ch[y][1]==q) ch[y][1]=p;
		pushup(q); pushup(p);
	}
	inline void splay(int x){
		q[top=1]=x;
		for(int i=x;!isroot(i);i=fa[i]) q[++top]=fa[i];
		for(int i=top;i;i--) pushdown(q[i]);
		for(;!isroot(x);rotate(x))
			if(!isroot(fa[x]))
				rotate((ch[fa[x]][0]==x)==(ch[fa[fa[x]]][0]==fa[x])?fa[x]:x);
	}
	void access(int x){
		for(int t=0;x;t=x,x=fa[x])
			splay(x),si[x]+=sz[ch[x][1]],si[x]-=sz[t],ch[x][1]=t,pushup(x); //
	}
	void makeroot(int x){
		access(x);
		splay(x);
		rev[x]^=1;
	}
	int find(int x){
		access(x);
		splay(x);
		while(ch[x][0]) x=ch[x][0];
		return x;
	}
	void split(int x,int y){
		makeroot(x);
		access(y);
		splay(y);
	}
	void cut(int x,int y){
		split(x,y);
		if(ch[y][0]==x)
			ch[y][0]=0, fa[x]=0;
        pushup(y); //
	}
	void link(int x,int y){
		split(x,y); // !!!
		fa[x]=y;
		si[y]+=sz[x]; //
		pushup(y); //
	}
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) lct::sz[i]=1;
	for(int i=1;i<=m;i++){
		char str[10]; int t1,t2;
		scanf("%s%d%d",&str,&t1,&t2);
		if(str[0]=='A')
			lct::link(t1,t2);
		if(str[0]=='Q') {
            lct::cut(t1,t2);
            lct::makeroot(t1);
            lct::makeroot(t2);
            cout<<1ll*lct::sz[t1]*lct::sz[t2]<<endl;
            lct::link(t1,t2);
		}
	}
}

```

### lazy tag

![1599704607666](C:\Users\10849\AppData\Roaming\Typora\typora-user-images\1599704607666.png)

``` cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1000000;

int n,m,val[N];

namespace lct {
	int top, q[N], ch[N][2], fa[N], rev[N];
	int a[N], tag[N], siz[N];
	inline void pushup(int x){
	    a[0] = siz[0] = 0;
		a[x] = a[ch[x][0]] + a[ch[x][1]] + val[x];
		siz[x] = siz[ch[x][0]] + siz[ch[x][1]] + 1;
	}
	void add(int p,int v) {
	    if(!p) return;
        val[p] += v;
        a[p] += siz[p]*v;
        tag[p] += v;
	}
	inline void pushdown(int x){
		if(rev[x]) {
            rev[ch[x][0]]^=1;
            rev[ch[x][1]]^=1;
            rev[x]^=1;
            swap(ch[x][0],ch[x][1]);
		}
		if(tag[x]) {
            add(ch[x][0],tag[x]);
            add(ch[x][1],tag[x]);
            tag[x]=0;
		}
	}
	inline bool isroot(int x){
		return ch[fa[x]][0]!=x && ch[fa[x]][1]!=x;
	}
	inline void rotate(int p){
		int q=fa[p], y=fa[q], x=ch[fa[p]][1]==p;
		ch[q][x]=ch[p][x^1]; fa[ch[q][x]]=q;
		ch[p][x^1]=q; fa[q]=p; fa[p]=y;
		if(y) if(ch[y][0]==q) ch[y][0]=p;
		else  if(ch[y][1]==q) ch[y][1]=p;
		pushup(q);
		pushup(p);
	}
	inline void splay(int x){
		q[top=1]=x;
		for(int i=x;!isroot(i);i=fa[i]) q[++top]=fa[i];
		for(int i=top;i;i--) pushdown(q[i]);
		for(;!isroot(x);rotate(x))
			if(!isroot(fa[x]))
				rotate((ch[fa[x]][0]==x)==(ch[fa[fa[x]]][0]==fa[x])?fa[x]:x);
	}
	void access(int x){
		for(int t=0;x;t=x,x=fa[x])
			splay(x),ch[x][1]=t,pushup(x);
	}
	void makeroot(int x){
		access(x);
		splay(x);
		rev[x]^=1;
	}
	int find(int x){
		access(x);
		splay(x);
		while(ch[x][0]) x=ch[x][0];
		return x;
	}
	void split(int x,int y){
		makeroot(x);
		access(y);
		splay(y);
	}
	void cut(int x,int y){
		split(x,y);
		if(ch[y][0]==x)
			ch[y][0]=0, fa[x]=0;
	}
	void link(int x,int y){
		makeroot(x);
		fa[x]=y;
		pushup(y);
	}
	int query(int x,int y) {
        split(x,y);
        return a[y];
	}
}

signed main(){
	ios::sync_with_stdio(false);
	int n,m,t1,t2,t3,t4;
	cin>>n>>m;
	for(int i=1;i<=n;i++) {
        lct::siz[i]=1;
	}
	for(int i=1;i<n;i++) {
        lct::link(i,i+1);
	}
	for(int i=1;i<=n;i++) {
        cin>>t1;
        val[i]=t1;
	}
	for(int i=1;i<=m;i++) {
        cin>>t1>>t2>>t3;
        if(t1==1) cin>>t4;
        if(t1==1) {
            lct::split(t2,t3);
            lct::add(t3,t4);
        }
        else {
            cout<<lct::query(t2,t3)<<endl;
        }
	}
}

```





## Euler Tour Tree 维护动态图连通性

``` cpp
// n <= 5000  m <= 5e+5
// MLE warning
#include<bits/stdc++.h>
#define N 16800000
#define M 1000006
using namespace std;
char ch;
inline void rd(int &x)
{
    for(;(ch=getchar()-'0')<0||ch>9;);
    for(x=ch;(ch=getchar()-'0')>=0&&ch<=9;
    x=(x<<3)+(x<<1)+ch);
}
bool intr[M],del[N],gdel[N];
int n,m,lev[M],hd[M][16],
Nxt[N],To[N],
gt,et=1,mp[5003][5003],nxt[N],to[N],
c[N][2],f[N],se[N],st[N],Se[N],St[N];

inline void upd(int x)
{
    Se[x]=se[x]+Se[c[x][0]]+Se[c[x][1]],
    St[x]=st[x]+St[c[x][0]]+St[c[x][1]];
}
inline void rotate(int x,bool t)
{
    register int y=f[x];
    f[y]?c[f[y]][c[f[y]][1]==y]=x:0;
    f[x]=f[y],c[y][t^1]=c[x][t];
    f[c[x][t]]=y,c[x][t]=y,f[y]=x;
    upd(y),upd(x);
}
inline void splay(int x,int to)
{
    int y;bool t1,t2;
    while(f[x]^to)
    {
        t1=c[y=f[x]][0]==x,t2=c[f[y]][0]==y;
        if(f[y]==to)
        {rotate(x,t1);return;}
        t1^t2?rotate(x,t1):rotate(y,t2);
        rotate(x,t2);
    }
}
inline void Gins(int u,int v,int l)
{
    hd[mp[u][v]][l]=++gt;
    u=l*n+u;
    splay(u,0),st[u]++,upd(u);
    nxt[gt]=nxt[u],nxt[u]=gt,to[gt]=v;
}
inline void Ins(int &x,int y,bool t)
{
    if(!y)return;
    while(c[x][t])x=c[x][t];
    c[x][t]=y,f[y]=x;
    splay(y,0),x=y;
}
inline int getr(int x)
{
    splay(x,0);
    while(c[x][0])x=c[x][0];
    splay(x,0);return x;
}
inline void reroot(int u)
{
    if(getr(u)==u)return;
    splay(u,0);
    register int x=c[u][0];c[u][0]=0,upd(u);
    Ins(u,x,1);
}
inline void link(int u,int v,int l)
{
    register int x=hd[mp[u][v]][l];
    intr[mp[u][v]]=intr[mp[v][u]]=1;
    u=l*n+u,v=l*n+v;
    reroot(v),splay(u,0),splay(v,0);
    se[u]++,se[v]++,upd(v),
    Nxt[x]=Nxt[u],Nxt[u]=x,To[x]=v,
    Nxt[x^1]=Nxt[v],Nxt[v]=x^1,To[x^1]=u;
    Ins(v,x,0),Ins(v,x^1,1);
    gdel[x]=gdel[x^1]=1;
    x=c[u][1];while(c[x][0])x=c[x][0];
    if(x)
    {
        splay(x,u);
        c[x][0]=v,f[v]=x,upd(x);
    }
    else c[u][1]=v,f[v]=u;
    upd(u);
}
inline void cut(int u,int v,int l)
{
    register int x=hd[mp[u][v]][l];
    u=l*n+u,v=l*n+v;
    reroot(u);
    splay(x,0);
    splay(x^1,x);
    f[c[x^1][0]]=f[c[x^1][1]]=f[c[x][0]]=0;
    splay(u,0),se[u]--,upd(u);
    Ins(u,c[x^1][1],1);
    splay(v,0),se[v]--,upd(v);
}
inline void pushup(int u,int v,int l,bool t)
{
    del[hd[mp[u][v]][l]]=del[hd[mp[v][u]][l]]=1;
    register int x=mp[u][v];
    lev[x]=lev[x^1]=l;
    Gins(u,v,l),Gins(v,u,l);
    if(t)link(u,v,l);
}
void dfse(int x)
{
    if(!Se[x])return;
    if(se[x])
    {
        for(int i=Nxt[x];i;i=Nxt[i])
        if(!del[i])pushup((x-1)%n+1,(To[i]-1)%n+1,(x-1)/n,1);
        Nxt[x]=se[x]=0;
    }
    dfse(c[x][0]),dfse(c[x][1]),upd(x);
}
bool dfst(int x,int y)
{
    if(!St[x])return 0;
    if(st[x])
    {
        for(int i=nxt[x];i;i=nxt[i])
        {
            if(!(del[i]|gdel[i]))
            {
                register int l=(x-1)/n;
                if(getr(l*n+to[i])^y)
                pushup((x-1)%n+1,(to[i]-1)%n+1,(x-1)/n,0);
                else
                {
                    upd(x),x=(x-1)%n+1;
                    for(int j=0;j<=l;j++)
                    link(x,to[i],j);
                    return 1;
                }
            }
            st[x]--,nxt[x]=nxt[i];
        }
    }
    St[x]=0;
    if(dfst(c[x][0],y))return 1;
    return dfst(c[x][1],y);
}
inline bool rec(int u,int v,int l)
{
    u=l*n+u,v=l*n+v;
    splay(u,0),splay(v,0);
    if(St[u]>St[v])swap(u,v);
    register int x=getr(v);
    dfse(u);
    return dfst(u,x);
}
int op,u,v,x,ans;
int main()
{
    rd(n),rd(m),gt=n<<4|1;
    while(m--)
    {
        rd(op),rd(u),rd(v),u^=ans,v^=ans;
        if(!op)
        {
            mp[u][v]=++et,mp[v][u]=++et;
            Gins(u,v,0),Gins(v,u,0);
            if(getr(u)^getr(v))link(u,v,0);
        }
        else if(op>1)
        getr(u)==getr(v)?puts("Y"),ans=u:(puts("N"),ans=v);
        else
        {
            x=mp[u][v];
            for(int i=0;i<=lev[x];i++)
            del[hd[x][i]]=del[hd[x^1][i]]=1;
            if(intr[x])
            {
                for(int i=lev[x];i>=0;i--)
                cut(u,v,i);
                for(int i=lev[x];i>=0;i--)
                if(rec(u,v,i))break;
            }
        }
    }
}

```



## 莫队算法

### 普通莫队

``` cpp
// Query sigma(c(i)^2), where c(i) is the number of occurrence of i
int n,m,k,b[100005];
long long cnt[100005],res[100005];
struct query{int l,r,block,id;}a[100005];
bool operator <(query a,query b){
	if(a.block==b.block)return a.r<b.r;
	return a.block<b.block;
}
int main(){
	scanf("%d%d%d",&n,&m,&k);
	int size=sqrt(n);
	for(int i=1;i<=n;i++) scanf("%d",&b[i]);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&a[i].l,&a[i].r);
		a[i].id=i;
		a[i].block=(a[i].l-1)/size+1;
    }
	sort(a+1,a+m+1);
	int l=1,r=0; long long ans=0;
	for(int i=1;i<=m;i++){
		while(l>a[i].l) l--,cnt[b[l]]++,ans+=2*cnt[b[l]]-1;
		while(r<a[i].r) r++,cnt[b[r]]++,ans+=2*cnt[b[r]]-1;
		while(l<a[i].l) cnt[b[l]]--,ans-=2*cnt[b[l]]+1,l++;
		while(r>a[i].r) cnt[b[r]]--,ans-=2*cnt[b[r]]+1,r--;
		res[a[i].id]=ans;
    }
	for(int i=1;i<=m;i++) printf("%lld\n",res[i]);
}
```



### 带修改莫队

``` cpp
// In each query, How many sub-interval whose XOR sum is 0
#define reset(x) memset(x,0,sizeof(x))

struct Query {
	long long l, r, t;
	long long result;
} query[100005];

long long n, m, tot, a[100005], l, r, pos, change[100005], be[100005], s[100005], pLeft, pRight, pTime, bs[100005];
long long cnt[4000005], ans;

bool cmp(Query& a, Query& b) {
	return be[a.l] == be[b.l] ? (be[a.r] == be[b.r] ? a.t < b.t : a.r < b.r) : (a.l < b.l);
}

bool cmp_back(Query& a, Query& b) {
	return a.t < b.t;
}

void pushByPosi(long long posi) {
	ans += cnt[s[posi]];
	cnt[s[posi]]++;
}

void popByPosi(long long posi) {
	cnt[s[posi]]--;
	ans -= cnt[s[posi]];
}

void pushByTime(long long tim) {
	if (change[tim]) {
		long long p = change[tim];
		swap(a[p], a[p + 1]);
		if (pLeft <= p && p <= pRight) {
			cnt[s[p]]--;
			ans -= cnt[s[p]];
		}
		s[p] = s[p - 1] ^ s[p + 1] ^ s[p];
		if (pLeft <= p && p <= pRight) {
			ans += cnt[s[p]];
			cnt[s[p]]++;
		}
	}
}

void popByTime(long long tim) {
	pushByTime(tim);
}

int main() {
	ios::sync_with_stdio(false);
	while (cin >> n >> m) {
		tot = l = r = pos = pLeft = pRight = pTime = ans = 0;
		reset(a); reset(change); reset(be); reset(s); reset(cnt); reset(query);
		for (long long i = 1; i <= n; i++) cin >> a[i];
		for (long long i = 1; i <= m; i++) {
			long long type;
			cin >> type;
			if (type == 1) {
				cin >> l >> r;
				query[++tot].l = l;
				query[tot].r = r;
				query[tot].t = i;
			}
			if (type == 2) {
				cin >> pos;
				change[i] = pos;
			}
		}
		long long unitSize = pow(tot, 0.6667);
		for (long long i = 1; i <= tot; i++) {
			be[i] = i / unitSize + 1;
		}
		sort(query + 1, query + tot + 1, cmp);
		for (long long i = 1; i <= n; i++)
			s[i] = s[i - 1] ^ a[i];
		pLeft = 1;
		pRight = 0;
		pTime = 0;
		//cnt[0] = 1;
		for (long long i = 1; i <= tot; i++) {
			long long qLeft = query[i].l - 1, qRight = query[i].r, qTime = query[i].t;
			while (qTime > pTime) pushByTime(++pTime);
			while (qTime < pTime) popByTime(pTime--);
			while (qLeft < pLeft) pushByPosi(--pLeft);
			while (qRight > pRight) pushByPosi(++pRight);
			while (qLeft > pLeft) popByPosi(pLeft++);
			while (qRight < pRight) popByPosi(pRight--);

			query[i].result = (qRight - qLeft + 1) * (qRight - qLeft) / 2 - ans;
		}

		sort(query + 1, query + tot + 1, cmp_back);
		for (long long i = 1; i <= tot; i++)
			cout << query[i].result << endl;
	}
}

```



### 树上莫队

``` cpp
// Count on a Tree II (spoj10707)
vector <int> g[100005];
map <int,int> mp;
int a[200005],b[200005],cnt[200005],src[100005],dep[100005],seq[100005],vis[100005],fa[100005][18],st[100005],en[100005],ans,ind,n,m,blocksize;
int _a[200005];
struct Query {
    int x,y,l,ans,id;
    bool operator < (const Query &tar) {
        return ((x/blocksize == tar.x/blocksize)?(y<tar.y):(x<tar.x));
    }
} q[200005];

void add(int p) {
    b[seq[p]]++;
    if(b[seq[p]]&1) {cnt[a[p]]++;if(cnt[a[p]]==1) ++ans;}
    else {cnt[a[p]]--;if(cnt[a[p]]==0) --ans;}
}
void dec(int p) {
    b[seq[p]]--;
    if(b[seq[p]]&1) {cnt[a[p]]++;if(cnt[a[p]]==1) ++ans;}
    else {cnt[a[p]]--;if(cnt[a[p]]==0) --ans;}
}
void dfs(int p) {
    vis[p]=1;
    seq[++ind]=p; st[p]=ind;
    for(int i=0;i<g[p].size();i++) {
        if(vis[g[p][i]]) continue;
        fa[g[p][i]][0]=p;
        dep[g[p][i]]=dep[p]+1;
        dfs(g[p][i]);
    }
    seq[++ind]=p; en[p]=ind;
}
void lca_presolve() {
    for(int i=1;i<18;i++)
        for(int j=1;j<=n;j++)
            fa[j][i]=fa[fa[j][i-1]][i-1];
}
int lca(int p,int q) {
    if(dep[p]<dep[q]) swap(p,q);
    for(int i=17;i>=0;--i)
        if(dep[fa[p][i]]>=dep[q]) p=fa[p][i];
    for(int i=17;i>=0;--i)
        if(fa[p][i]-fa[q][i]) p=fa[p][i],q=fa[q][i];
    if(p-q) p=fa[p][0],q=fa[q][0];
    return p;
}
int main() {
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>src[i], mp[src[i]]++;
    int __idx=0;
    for(map<int,int>::iterator it=mp.begin(); it!=mp.end(); it++)
        it->second = ++__idx;
    for(int i=1;i<=n;i++) src[i]=mp[src[i]];
    for(int i=1;i<n;i++) {
        int u,v;
        cin>>u>>v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dep[1]=1;
    dfs(1);
    lca_presolve();
    for(int i=1;i<=2*n;i++) a[i]=src[seq[i]];
    for(int i=1;i<=m;i++) {
        cin>>q[i].x>>q[i].y;
        q[i].id=i;
        q[i].l=lca(q[i].x,q[i].y);
        if(st[q[i].x]>st[q[i].y]) swap(q[i].x,q[i].y);
        if(q[i].x==q[i].l) {
            q[i].l=0;
            q[i].x=st[q[i].x];
            q[i].y=st[q[i].y];
        }
        else {
            q[i].l=st[q[i].l];
            q[i].x=en[q[i].x];
            q[i].y=st[q[i].y];
            if(q[i].x>q[i].y) swap(q[i].x,q[i].y);
        }
    }
    blocksize = sqrt(m);
    sort(q+1,q+m+1);
    int L=1,R=0;
    for(int i=1;i<=m;i++) {
        while(R<q[i].y) ++R,add(R);
        while(L>q[i].x) --L,add(L);
        while(R>q[i].y) dec(R),--R;
        while(L<q[i].x) dec(L),++L;
        if(q[i].l==0) {
            q[i].ans = ans;
        }
        else {
            add(q[i].l);
            q[i].ans = ans;
            dec(q[i].l);
        }
        _a[q[i].id]=q[i].ans;
    }
    for(int i=1;i<=m;i++) cout<<_a[i]<<endl;
}

```





## STL

### rope

使用 `rope`，需要引入头文件 `ext/rope`，并且使用命名空间 `__gnu_cxx`

定义 `rope<T> rp;`

简单用例

```
rope<int> *rp[maxn];
his[0]=new rope<char>();
his[i]=new rope<char>(*his[i-1]);
```

常见操作

| 代码             | 功能                                   |
| ---------------- | -------------------------------------- |
| `push_back(x)`   | 在末尾追加元素 `x`                     |
| `insert(pos,x)`  | 插入元素 `x` 使得它成为序列第 `pos` 个 |
| `erase(pos,x)`   | 从 `pos` 开始删除 `k` 个               |
| `replace(pos,x)` | 从 `pos` 开始替换成 `x`                |
| `at(x)`          | 访问第 `x` 个元素                      |

原题代码

```cpp
#include <bits/stdc++.h>
#include <ext/rope>
using namespace std;
using namespace __gnu_cxx;
const int N = 300005;

int n,tot,opt,t,k,x;
rope <int>* s[N];

signed main() {
    ios::sync_with_stdio(false);
    cin>>n;
    s[0]=new rope<int>();
    for(int i=1;i<=n;i++) {
        cin>>opt>>t>>k;
        switch (opt) {
        case 1:
            cin>>x;
            s[++tot]=new rope<int>(*s[t]);
            s[tot]->insert(k-1,x);
            break;
        case 2:
            s[++tot]=new rope<int>(*s[t]);
            s[tot]->erase(k-1,1);
            break;
        default:
            cout<<s[t]->at(k-1)<<endl;
        }
    }
}

```



## 可持久化 0-1 Trie

``` cpp
#include<bits/stdc++.h>
using namespace std;

int ch[1000005][2],val[1000005],cnt[1000005],root[1000005],ts[105],ind,n,m;

void insert(int p,int p0,int dep) {
    ch[p][0]=ch[p0][0];
    ch[p][1]=ch[p0][1];
    if(dep==30) return;
    if(ch[p0][ts[dep+1]]==0) {
        ch[p][ts[dep+1]]=++ind;
        val[ind]=ts[dep+1];
        cnt[ind]=1;
        insert(ind,ch[p0][ts[dep+1]],dep+1);
    }
    else {
        ch[p][ts[dep+1]]=++ind;
        val[ind]=ts[dep+1];
        cnt[ch[p][ts[dep+1]]]=cnt[ch[p0][ts[dep+1]]]+1;
        insert(ch[p][ts[dep+1]],ch[p0][ts[dep+1]],dep+1);
    }
}

void trie_insert(int rtx,int num) {
    for(int i=1;i<=30;i++)
        ts[i]=(num>>(30-i))&1;
    insert(root[rtx],root[rtx-1],0);
}

int xormax(int rtx,int rty,int num) {
    int p=root[rtx], q=root[rty], ans=0;
    for(int i=29;i>=0;i--) {
        if((num>>i)&1) {
            if(cnt[ch[q][0]]-cnt[ch[p][0]]) ans=ans*2+1, p=ch[p][0], q=ch[q][0];
            else ans=ans*2, p=ch[p][1], q=ch[q][1];
        }
        else {
            if(cnt[ch[q][1]]-cnt[ch[p][1]]) ans=ans*2+1, p=ch[p][1], q=ch[q][1];
            else ans=ans*2, p=ch[p][0], q=ch[q][0];
        }
    }
    return ans;
}

int main() {
    cin>>n;
    for(int i=1;i<=n;i++) {
        int t;
        cin>>t;
        root[i]=++ind;
        trie_insert(i,t);
    }
    cin>>m;
    for(int i=1;i<=m;i++) {
        int t1,t2,t3;
        cin>>t1>>t2>>t3;
        t1--;
        cout<<xormax(t1,t2,t3)<<endl;
    }
}
```

