## 线性基

线性基是向量空间的一组基，通常可以解决有关异或的一些题目。

通俗一点的讲法就是由一个集合构造出来的另一个集合，它有以下几个性质：

- 线性基的元素能相互异或得到原集合的元素的所有相互异或得到的值。
- 线性基是满足性质 1 的最小的集合。
- 线性基没有异或和为 0 的子集。
- 线性基中每个元素的异或方案唯一，也就是说，线性基中不同的异或组合异或出的数都是不一样的。
- 线性基中每个元素的二进制最高位互不相同。

构造线性基的方法如下：

对原集合的每个数 p 转为二进制，从高位向低位扫，对于第 $x$ 位是 1 的，如果 $a_x$ 不存在，那么令 $a_x=p$ 并结束扫描，如果存在，令 $p=p~\text{xor}~a_x$ 。

### 基础模板

``` cpp
// Linear Base to Get Max xor sum
// Method: insert(x) solve()
struct linear_base {
    int a[64];
    void insert(int k) {
        for(int j=63; j>=0; --j)
            if((k>>j)&1ll)
                if(a[j]==0) {a[j]=k;break;}
                else k^=a[j];
    }
    int solve() { // 最大异或和
        int ans = 0;
        for(int i=59; i>=0; --i)
            if((ans^a[i]) > ans) ans^=a[i];
        return ans;
    }
} l;
```

bitset版本

``` cpp
struct linear_base {
    bitset <1024> a[1024];
    void insert(bitset<1024> k) {
        for(int j=1023; j>=0; --j)
            if((k>>j)[0])
                if(a[j]==0) {a[j]=k;break;}
                else k^=a[j];
    }
} lb;
```

**查询原集合内任意几个元素 xor 的最大值**：将线性基从高位向低位扫，若 xor 上当前扫到的 $a_x$ 答案变大，就把答案异或上 $a_x$ 。

> 因为从高往低位扫，若当前扫到第 $i$ 位，意味着可以保证答案的第 $i$ 位为 1，且后面没有机会改变第 $i$ 位。

**查询原集合内任意几个元素 xor 的最小值**：就是线性基集合所有元素中最小的那个。

**查询某个数是否能被异或出来**：类似于插入，如果最后插入的数 $p$ 被异或成了 0，则能被异或出来。

**求第k大**：把 $k$ 二进制拆分，如果 $k$ 的第 $i$ 位上是 $1$，$ans\oplus =b[i]$

**在线删除**：给一个序列，有三种操作，一是往序列中插入一个数，二是删除这个序列中的一个数，三要求你维护这个序列的线性基。

重点是删除操作，如果要删除的数 x 在线性基外，那么直接删掉即可，问题是假如它在线性基内，把他删掉之后可能序列中其他的数可以填进来。现在讨论一下 x 在线性基内的做法：
 
没有在线性基中的数，一定是因为线性基中的若干个数可以异或得到他，那么可以记录一下不在线性基中的数都是由线性基中的哪些数异或得到的，那么每一个线性基外的数对应一个集合 S，这个集合内就是线性基中那些异或起来可以得到他的数。

假如线性基外的某一个数的 S 中包含 x，那么就不需要删除 x，把这个数删除即可。原因是这个数在线性基中是可以代替 x 的，那么就当这个数代替了 x，然后 x 被删除了，然后把线性基中的 x 当做这个数即可，这样的话线性基不会有变化。（实现起来并不需要维护集合 S，而是直接维护有哪些数可以代替线性基中的数就好了）

假如 x 不被线性基外的任何一个数的 S 包含，那么就另外造一个集合 P，记录线性基中这个数插入进来的时候异或过哪些数。然后找到线性基中最小的并且 P 包含 x 的数，让他异或线性基中其他包含 x 的数即可（包括自己，自己异或完自己后自己这一位就变成了 0），这样就能消除 x 在线性基中的影响（事实上就等价于用最小的数代替了它）。

总之，由于如果修改了线性基中的某一位会影响到一些比它小的位，所以一般不能修改，要么改最小的并且不会影响到下面的位。

**离线删除**：上面的问题并没有强制在线，所以也可以离线做。离线的话其实更简单。我们可以找到线性基中对于每一个数，可以代替他们的那些数，那么可以使线性基优先存删除时间晚的，那么就消除了上面的把他删掉之后可能序列中其他的数可以填进来这样的问题，其余操作一样。

具体实现起来就是在插入一个新数的时候，对比一下这个数的删除时间和当前枚举到的线性基的某一位的删除时间，假如比他晚就直接替换掉，否则异或它然后继续枚举。这样就少维护了一个集合。

**求交**：即对于两个线性空间 $V_1,V_2$，求它们的交 $V_1\cap V_2$，首先，两个线性空间的交显然还是线性空间

> 引理：若 $V_1,V_2$ 是线性空间，$B_1,B_2$ 分别是他们的一组基，令 $W=B_2 \cap V_1$，若 $B_1 \cup (B2 \setminus W)$ 线性无关，则 $W$ 是 $V_1 \cap V_2$ 的一组基。

但是 $B_1 \cup (B_2 \setminus W)$ 有可能线性相关，这时我们只需要换一组基即可。假如当前加入的元素为 $x$ ，若 $x$ 不能被 $B_1 \cup B'_2$ 表示，那么直接在 $B_2'$ 中加入 $x$ 即可；否则 $x$ 一定能被 $B_1 \cup (B_2' \setminus W)$ 的恰好一个子集表示，设 $x=\text{xor(S)} \cap \text{xor(T)}$ ，其中 $S \subseteq B_1,T \subseteq B_2' \setminus W$ ，在 $B_2'$ 中加入 $\text{xor(S)}$ 即可，且此时$S\in W$，在 $W$ 中也加入 $S$ 即可。总复杂度 $O(d^2)$，其中 $d$ 为维数。

### 线性基练习题

> 有一个$2^k\cdot 2^k$ 的全零矩阵 $M$，给出 $2^k\cdot 2^k$ 的 $01$ 矩阵 $F$，现在可以将 $F$ 的左上角置于 $M$ 的任一位置（超出部分就循环，$2^k$ 的下一个就是 $1$），然后相应位置相异或。现在可以执行任意次以上操作：将 $F$ 放于某个位置，执行对应的异或操作。问最后不同的 $M$ 有多少个。

很显然我们可以 $F$ 放在每一个位置的异或结果都算出来，放在一起，变成一个集合，那么最终的答案就是这个集合内的元素相互异或，有多少种不同的结果。

把它压成一个串，这样每个结果就是一个向量。把它们视作一个向量组，那么在异或的意义下，设它的秩是 $r$，则答案显然是 $2^r$。求线性基，搬运一个板子，把 `int` 换成 `bitset` 即可。

> 给定 $n$ 个点 $m$ 条边的带权无向图，权值是小于 $2^{1000}$ 的二进制数。有 $q$ 次操作，每次操作可能会新增一条边，删除一条边或者修改某条边的权值。你需要在每次操作后，输出图中的最大权环，环的权值定义为环上所有边的异或和，环可以多次经过某个点或某条边。$n,m \leq 500, q \leq 1000$

一个很显然的 70 分暴力是直接按照 [WC2011] XOR 那题的方法做，然而**线性基不支持撤销**，我们要向将冗余的部分优化掉，需要另寻思路。考虑到每条边的**存在时间是一个区间**，容易想到**线段树分治**。

首先**搞出原图的一棵生成树**，这样我们就可以让多出来的每条边对应唯一的一个环，于是每条边所对应的**环的权值**也就随之确定，这样问题就转化为，一开始集合中有 $m-n+1$ 个数，现在我们要操作 $q$ 次，每次新增一个数，删除一个数，或者修改一个数，不妨把修改一个数视为删除后再添加，那么就**只有添加和删除两种操作**，于是我们处理出**每个数存在的时间区间**，将它**挂到线段树上**，然后跑线段树分治。具体地，每递归到一个节点时，**拷贝一份父亲节点的线性基**，并在其中**插入这个节点上挂的数字**，就可以得到这个点的线性基，递归到叶子节点的时候，求一下线性基中的**最大异或和**即可。注意有些新增的边不会被删除，所以最后要把它们处理一下。

> 给定一棵树，每个点有一个权值。有若干询问，每次给定一条简单路径，问这条路径上的所有点中，选择一部分异或起来，可以得到的最大值是多少。

首先显然可以暴力树剖，用线段树维护线性基，只是这样复杂度略高 $O(q \log^4 n)$。用树上倍增维护，可以将复杂度降到 $O(q \log^3 n)$。考虑到对两个区间进行合并时，重复部分并不会影响，所以可以借鉴 ST 表的思路，将复杂度降到 $O(n \log^3 n + q \log^2 n)$

 [SGU 275 to xor or not xor](https://vjudge.net/problem/SGU-275) 

 [HDU 3949 XOR](https://loj.ac/problem/161) 

 [Luogu P4151\[WC2011\]最大 XOR 和路径](https://www.luogu.com.cn/problem/P4151) 